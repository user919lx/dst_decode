{"./":{"url":"./","title":"序言","keywords":"","body":"这个系列讲什么 解读源码，用全新的视角重新认识我们熟悉的饥荒世界。我会讲解饥荒里涉及的基本编程概念，游戏运行的机制等等。 我在几年前曾经兴致勃勃地想要写一个完整的饥荒Mod教程，但后来弃坑了，主要就是写起来太过费劲，每一篇都要写上万字，查阅许多资料。当时还是个刚入行的编程菜鸟，啥都不懂，读源码也很吃力。这几年我已经成长成了一个资深程序员，对编程有了深入的理解，读源码已经是如同喝水一般轻松了。不过工作比较忙，时间紧张，也没精力再像以前一样写上万字的详细教程了。所以我就打算先写这个科普向的系列，在有限的时间精力行下，给大家带来一些对Mod制作的兴趣。这个系列虽然是以饥荒为切入点，但实际讲解的是游戏编程的知识，其中很多概念比如Prefab、Component等等，都是经典的游戏编程概念，在许多游戏中都是相通的，如果你能理解这些概念，不仅能用在其它游戏Mod的编程，甚至可以由此入门尝试编写自己的游戏。 谁适合阅读？ 想学Mod制作的，想创建自己的地图的，想自己修改Mod的，想更好地使用控制台的，想要深入了解游戏机制的，总之，对饥荒的代码和运转机制感兴趣的一切玩家，都可以读一读。如果你对游戏编程感兴趣，饥荒的代码也是很好的学习材料。 对于想学Mod、制作自己的地图的同学，可以通过阅读这个系列，深入理解游戏的编程框架，降低阅读游戏源码的门槛。Mod制作有三个阶段：刚入门的，只能跟着教程一步步走，做出教程示例的东西，或者在这个基础上稍作调整。更进一步，在大量学习了别人写出来的教程之后，把知识串联起来，做出自己想要的东西。而最高级的Mod制作者，则是可以自己阅读游戏和其他Mod的源码，从中获取知识，进而可以在游戏框架内实现任何需求。我这个教程的目的之一，就是教大家如何成为一个最高级的Mod制作者。 即使是不打算做Mod的同学，也可以通过阅读这个教程，对游戏的机制有更本质的理解，从而更好地玩游戏。 会怎么讲？ 首先第一期，我会介绍这个世界的构成元素，这一期不会涉及具体的代码，只是介绍各种概念，建立对世界的整体认知，为后续学习打下基础。接着我会在每一期里仔细解读一个元素，并且写一个小Mod来展示如何应用。Mod会发布在steam创意工坊上，也会发布在github上。 我之前建了一个饥荒Mod答疑QQ群 559477977，欢迎加入。 源码在哪里？ 官方的源码被打包成了一个zip文件，位于游戏根目录/data/databundles/scripts.zip，解压之后即可阅读lua文件 创意工坊的Mod源码，位于游戏根目录/mods/workshop-xxxx，可以直接阅读。 推荐大家使用VS Code + lua拓展插件进行阅读，有代码高亮，还能以项目的形式进行浏览多个文件，比原生的文本编辑器要方便得多。 附加的代码 部分章节中，为了便于学习理解，我制作了小mod，可以参考我的项目 dst_mod_tutorial "},"main/c1_the_world.html":{"url":"main/c1_the_world.html","title":"第一章 世界的构成","keywords":"","body":"万物起源 当你开了一个新档，第一次进入游戏的时候，会有一个生成世界的步骤。这个过程可以称之为世界的初始化。系统首先绘制世界地图，将各种地皮串联起来。然后在每一个地皮上放置一些资源和奇遇。世界地图是随机生成的，但也是有一定的规律，可以进行设置的。掌握了编程的方法后，你就可以绘制出自己想要的世界地图了。不过本期的重点并不在于此，后续会有一期专门讲解地图。这里想说的是各种资源，比如花、草、蜜蜂、蝴蝶、猪人等等。他们都有一个统一的称谓：Prefab，翻译成中文叫作预制物。除了各种资源之外，各种特效、建筑物，那些可以与玩家发生互动的或者不能互动的，看得见的或者看不见的东西，都可以称为Prefab。另外，我们还可以把Prefab理解为生物学里的染色体，它的基因记录了一类物体的初始化方法（应该如何生成，包含外观、各项属性以及行为方式等等）。系统会根据染色体上的基因来将Prefab生成实体，投放到游戏系统里。每种东西都有自己的Prefab，有着唯一的名字，有一条控制台命令用于生成Prefab：c_spawn(\"{prefab}\", amount),这里面的{prefab}就是就是指Prefab的名字，比如spider,pigman等等。有一些物种之间很相近，比如各类蜘蛛，他们会共用一部分初始化的内容，但也会有各自的差异。除了使用游戏提供的Prefab，我们也可以根据需要，自己定义新的Prefab。这需要给Prefab起一个名字，提供一个初始化方法，最后再调用系统的函数进行注册，让系统知道有了一个新的Prefab。 游戏世界里丰富多彩的各种东西，本质上都是由各种Prefab生成的实体，它们之间的核心区别，就在于染色体上的基因，也就是初始化方法。Prefab是多种多样的，它们的初始化方法也各不相同，但也有一些共性。接下来就讲讲，Prefab的初始化都有哪些内容。如果有兴趣的同学，也可以直接阅读源码文件夹下的Prefabs文件夹。 灵魂 首先第一步，添加灵魂，也就是创建一个实体，这是实现与游戏世界交互的第一步。在这一步里面，系统会赋予实体一个唯一的ID，这是与其他实体区别的标识，即使属于同一个Prefab，也拥有各自不同的实体。除了赋予实体ID之外，系统还会分配相应的内存，记录这个实体的各种信息，比如创建时间，存档信息等等。在大多数Prefab的初始化方法中，第一行代码都是local inst = CreateEntity()，这里的CreateEntity就是系统提供的一个创建实体的方法，调用它会获得一个由游戏引擎创建的实体，同时还会记录实体id，创建时间等基本信息。这个实体，我们用inst来指代。注意，这个inst实际上也是个容器，用于存储各种数据，在CreateEntity方法中，真正返回的实体是被存在inst.entity下。在这一步创建的实体，只有一个灵魂和一些创建时记录的信息，既看不到，也做不了任何事情。 血肉 第二步，添加骨骼和血肉。实际上也就是为实体添加各种组件，并设置每个组件的初始化参数。组件可以分为两类，一类是底层游戏引擎提供的组件，比如位置组件Transform，动画组件AnimState等等，在联机版中为了实现机器之间的数据交换，还有网络组件Network，这些组件由游戏引擎提供，通过调用inst.entity.AddXxx来获得，数量不多，但都是与游戏引擎强相关的核心组件（比如位置、动画、光照、网络）。它们没有lua语言定义的源码，无法看到具体的功能，只能通过名字和参数去理解，然后模仿游戏里已有的lua代码的用法来使用。另一类是通过lua语言定义的组件，这些组件首先需要被声明为Component类，并给出一个唯一的名字，然后在Prefab的初始化方法中执行inst:AddComponent(\"{component}\")，这里的{component}就是组件的名字。 添加组件，是Prefab初始化方法中代码占篇幅最大的内容，常常可以占到60%以上。可以说，组件是染色体上的主要基因。组件种类以及初始化参数的不同，造就了这个世界丰富多彩的种群。比如人物都会有饱食和精神组件，但怪物没有。动物都有血量的组件，植物却没有。即使有着同样的组件，不同的Prefab也有不同的初始化参数。比如人物都可以吃食物，但机器人WX78还可以吃齿轮。游戏Mod中数量最多的当属人物Mod，每个人物都有自己独特的形象，这是因为他们通过inst.AnimState.SetBuild('{build_name}')读取了相应的设置。而一些比较有特色的人物，作者往往自己编写一个专属组件。比如我就为Samansha编写了组件Photosynthesis，用来实现Samansha的光合作用。组件是游戏机制的核心。各种功能不同的组件，为我们带来丰富多彩的游戏体验。比如Transform与位置相关，像是虫洞瞬移之类的动作，都需要借助Transform；AnimState与外形和动画相关，特定条件下改变人物外形，不同地动作下播放不同的动画，都需要借助AnimState；而游戏最基本的三围——饱食度、精神值、血量分别对应着hunger, sanity, health三个组件。只要能了解这些清楚各种组件的作用，就能极大地提升对游戏核心机制的理解。 动起来 第三步，添加状态图，也就是SG，全称是StateGraph，在业界更常用的称呼是有限状态机（finite-state machine，FSM）。这一步是可选的，对于一些比较简单的Prafab，比如特效，在生成之后，只播放了一遍动画之后就自动被移除了，很容易描述，就不需要设置SG。但对于玩家这样，或者一些有复杂行为的BOSS，能做出的行动非常多，每个行动下都会有不一样的表述。比如玩家，静止不动时，偶尔会打个哈欠；在地图上走动时，会动起手脚，踩到某些地板还会发出响声，自己的位置也会移动；战斗时，会挥舞武器进行攻击。这里的状态-State，指的是像「静止」、「走动」、「攻击」这样一个整体的概括。前面说到，游戏的核心处理逻辑是在组件里写的，比如攻击怪物会扣多少血，一秒内可以移动多远，都是通过对应组件来完成的。这里的State承担的主要功能是，写清楚这个状态下应该播放什么动画和音效，触发相应组件的计算逻辑，在这个状态下的逐帧变化，以及如何转化为其他State等等。通常来说，有多套动画的生物，都会有自己的SG，并且哪怕是同一个State，不同的生物也有不同的表现，比如各种怪物都会有基础的「攻击」State,但每种怪物的攻击动画都是不一样的。攻击的「前摇」、「后摇」在不同怪物上的差异，主要就是通过SG来实现的。可以说，SG决定了如何、何时触发伤害计算逻辑，而组件则决定了具体伤害的数值以及造成伤害后的效果。细心的玩家肯定会发现，人物拿不同的武器进行攻击与空手攻击之间的攻击频率是有所差别的，这是因为「攻击」这个状态是有一个冷却时间的，在冷却时间内无法再次攻击。每一帧的时间为1/30秒，各类武器的冷却时间如下：鞭子17帧、书19帧、露西斧11帧、一般武器、提灯、海狸撕咬为13帧、空手为25帧。可以明显看出，空手的冷却时间很长，几乎是两倍于一般武器，所以能很明显地感受到攻击频率的不同。大多数人物都是用同一套SG，如果想要改变人物的攻击频率的话，就需要修改SG中相应的「攻击」状态的定义。 对State的定义，可以决定在一个State里动画、音效、组件触发的各种情况，乃至于在一个State结束后应该转向哪一个State，但不能完全覆盖State之间的转换。比如玩家进入到了「攻击」的State，刚刚抬手就被怪物的攻击打断，则会进入「硬直」的State，还有玩家在抬手攻击时，发现自己血量很低，马上吃了补血的食物，从而进入「进食」的State。这些类型的State转换都是通过触发某种事件（比如被攻击）或者动作（比如进食）来实现的。在代码的层面上，通过事件触发State转换，称之为EventHandler，通过动作触发State转换，称之为ActionHandler。事件触发State的机制，主要是为了方便各种组件进行State管理，比如战斗组件，只要在受到攻击伤害时，发送一个「被攻击受伤」事件，就能自动触发自身进入「硬直状态」。而动作触发State的机制，主要是为了玩家操作考虑。玩家与物品发生交互的过程中必然会产生动作，这个动作直接推动SG进入相应的State，播放对应的动画和音效。 研究SG，对于Mod制作者的意义在于，能够很方便地管理一些复杂生物的行为。将一个行为的各项代码组合到一个State里，在程序设计上会显得更为清晰，也容易维护，还可以实现逐帧操作，决定何时触发动画、音效的播放和组件逻辑的计算。而对于一般的玩家来说，则可以更深入地了解生物的行为细节，比如怪物的攻击频率和前摇后摇，硬直时间等等，从而更好地进行战斗。 下面的图是一个典型的状态图，简单直观容易理解 AI决策 第四步，添加AI。在玩家操作的角色之外，所有的生物都有自己的一套行为逻辑，也就是我们常说的AI。实现AI的方式有很多，如果判定标准和行为都比较简单，用上面说到的SG来实现就可以。但如果行为比较复杂，就需要其他的方式来实现了。在这个游戏中，复杂的AI是用「行为树」实现的，实质上就是一个树形结构图，每个节点代表一个行为或者条件判断逻辑，分支代表着不同条件对应的下一步行动。在游戏的源码中，与AI相关的代码有两部分，存储在两个文件夹下，分别是brains和behavious，前者代表着一个生物完整的行为树定义，后者则是具体到某个行为节点的形式逻辑。比如brain会决定兔人发现玩家持有肉类时，发起「攻击」行为。而behavious则会详细描述如何发起攻击，比如说要不要追击玩家，追多远会返回等等。 AI的理解和编写，还是相对复杂的，后续会专门写一篇来解读。研究清楚AI，对于Mod制作者来说，可以实现一些很智能的操作，比如让宠物自己干活。对普通玩家来说，则是能清晰地了解生物的行动模式，更好地去与各种生物进行互动。与SG的区别在于，SG主要强调状态的变化细节（比如在哪一帧触发伤害），而AI强调的是行为的决策（比如什么条件下会发起攻击）。 下面的图是一个简单的行为树，从根节点起，从左到右依次遍历子节点，直到执行成功（不满足条件的节点就是执行不成功，比如周围没有食物，则这个节点执行不成功，不会往下，而是接着访问下一个兄弟节点-是否有主人） 世界地图 除此之外，Prefab的初始化内容还包括添加TagAddTag和注册事件监听回调ListenForEvent，但这些内容不是必须的，通常是为了特定目的而设置，没有太多共性，在下一期专门介绍Prefab的内容中才会详细解释。 综上总结，Prefab 可以说是世界构成的基本元素，可以理解为成类似染色体的模板，让系统能快速生成一批同种类的东西，比如一群蜘蛛或者猪人或者一片森林。Prefab 以组件实现各种游戏逻辑，通过SG来控制自身动画、音效的播放、通过行为树来实现AI。 了解了 Prefab 之后，我们就可以来谈谈更大的内容了，那就是世界地图的生成方式。 在世界地图的生成过程中，Prefab是最小的单位，比如树木、干草、灌木、怪物、动物、石头等等，系统以某种方式将这些Prefab分散到地图上。在 Prefab 之上，是 Static Layout，中文为静态布局，可以理解为几个Prefab以固定的静态布局展现出来的东西。比如猪王就是一个典型的 Static Layout，在猪王周围总是有方尖碑，而且位置方向都是固定的。如果静态布局再加上能以某种方式触发的事件，就成了Set Piece，也就是我们常常说到的彩蛋。再往上一层，被称为Room。Room是最小的随机生成单位。一个Room，可以理解为一块小区域，它会有统一的地皮，还可以设置随机或固定数量的Prefab、Static Layout。同样是森林地皮，有的区域树很多，有的却很少，某些还会有海象巢穴，这是因为它们属于不同的Room。在Room之上，是Task，一个Task内可以包含若干个Room，也可以理解为是一个大区块。比如一大片草原，就是一个草原的Task，会有很多个不同的Room，某些Room有很多牛，而另一些则有很多兔子。再往上，是Task Set，实质上就是一整个世界，会囊括很多个Task。不同的Task Set有不同的地图设计和生成机制，比如一般游戏模式下进入游戏的世界被称为forest，而敲碎地洞进去的世界，被称为cave，它们各自代表着一个Task Set，很明显两者的地图是大不相同的。 那么世界是如何生成的呢？首先，根据玩家的设置，获取对应的Task Set，如果没有进行修改，默认会取用名为forest的Task Set。然后根据Task Set的设置，生成若干个Task，并以某种机制把这些Task串联起来。然后在每个Task上生成对应的Room，最后在每个Room上放置适当数量的Prefab和Static Layout，世界的生成就完成了。 对于Mod制作者来说，如果你希望设计独特的地图，或者添加某些特定的区域，就需要研究世界地图是怎样生成的，比如我的Samansha人物Mod，就添加一个区域来生成特有的鹿。对一般玩家来说，了解世界的生成机制，就有利于快速找到一些有用的资源，比如海象屋，沼泽地芦苇丛等等。 交互界面 到这里，世界的构成就已经讲完了，但我还想要再补充游戏的交互界面的知识。进入游戏后的各种按钮，状态指示器等等，都被称为Widget，中文叫小部件。它就是很小的一个元素，为了特定的需求服务，比如显示饱食度，或者浏览一个箱子的内部储存等等。而一些要占据整个屏幕的东西，比如选人画面、小地图画面等，就被称为Screen。 对于Mod制作者来说，想要实现一些特殊的UI操作，就必须了解Widget和Screen。而对于一般玩家来说，了解这些，主要是弄清楚各种按钮的交互作用。 好了，本期的介绍就到这里，下一期会详细讲解Prefab，除了更细致地讲解Prefab的生成之外，还会介绍各种典型的Prefab，欢迎关注。 "},"main/c2_entity_and_prefab.html":{"url":"main/c2_entity_and_prefab.html","title":"第二章 entity与prefab","keywords":"","body":"引言 entity，中文一般称为实体，指的是在游戏中出现的一切看得见和看不见的物体。比如控制世界变化的TheWorld，就是一个看不见的实体，随处可见的花草，也是实体。每个实体经由系统生成，会分配一个游戏全局唯一的ID，称为GUID(GLOBAL Unique ID)。 创建实体没有任何门槛，在创建之后你也可以随意改造。同样的，也可以改造一个已有的实体，你甚至可以把一个猪人变成蜘蛛。如果我希望生成一只蜘蛛，首先是创建一个实体，然后给它添加蜘蛛的动画，再加上蜘蛛具备的一些能力，添加SG和brain。但是，如果每次在需要生成某一类entity（比如蜘蛛）的时候，都要写上大段的代码（下文简称为初始化代码），就很不方便。而且也不利于后续维护修改，比如要调整蜘蛛的属性，就需要在每一个生成代码里都进行修改。 为了解决这个问题，最直接的想法是，把初始化代码写成一个初始化函数，每次要生成蜘蛛的时候，就调用这个函数。这样一来，无论是使用还是维护，都方便了许多。但仍然存在问题：如果要生成的entity类别很多，有几百个，那就得写几百个函数，这些函数名要维护起来也会有点麻烦。另外，entity还需要关联动画、音效等资源，如果这部分代码写在创建函数里，也不太合适。 更进一步的方案是，制作一个模板，存放所有能体现这个entity独特性的东西，包括各种资源和初始化代码，并且为这个模板取一个唯一的名字，然后把这个名字注册到系统中。然后构建一个生成函数，可以根据模板信息自动生成相应的实体。当系统需要生成这一类实体的时候，直接根据名字找到模板来生成就可以了，这就是prefab的由来。这是个经典的游戏编程概念，中文名一般称为预制物或预制体。 prefab与entity的区别在于，entity是实实在在会占用大量系统资源，每一个entity都是独立存储计算，有自己的数据，数量越多，消耗的资源越多。而prefab只是个模板，仅仅占用很小的固定资源，在游戏过程中不会发生变化。 对编程有基本了解的同学，都知道class这个经典的概念。class与prefab之间也有区别。prefab一经定义，就无法在游戏运行中再做修改。而在许多解释型语言中，都提供了在运行中动态修改class的能力。 简而言之，各种各样不同的Prefab作为模板，根据需要生成了各种entity，从而构成了丰富多彩的游戏世界。 本篇会从源码的角度，剖析prefab是如何生成的。 注：下文涉及代码的地方都会给出文件的相对路径，默认根目录是游戏的代码文件夹，也就是scripts prefab的定义 所有的prefab都通过Prefab类来构建，实质上是Prefab类的一个实例。 Prefab类的定义代码写在prefabs.lua文件里，完整的构建函数形如Prefab(name, fn, assets, deps, force_path_search)，这几个参数的含义如下 name: prefab的名称，必须是唯一的，不能与其它prefab的名称重复。这个名称会注册到系统里，可以在游戏控制台中通过c_spawn(\"{name}\")来生成对应的prefab fn: prefab的初始化函数，当系统生成相应prefab的实体时，会执行这个初始化函数，生成对应的prefab。不同prefab的区别就在于这个初始化函数的不同 assets: 相关的动画、音效等静态资源文件的路径 deps: 相关的Prefab依赖 force_path_search: 强制搜索路径 大多数情况下，都只会用到name, fn, assets这三个参数，deps和force_path_search一般是可以忽略的。 而在这其中，最重要的就是初始化函数fn，它描述了一个Prefab在生成时应该如何设置，比如使用何种动画骨架，最开始的外形如何，是否能发起攻击等等，如果有HP的话，初始化的血量是多少等等。如果你想了解一个物体的详细参数，最直接有效的方法就是找到这个物体的Prefab的初始化函数，仔细阅读。 初始化函数fn 初始化函数的代码，在复杂的Prefab中通常比较庞杂，像生成人物的代码就有足足1000多行，如果只是单纯地逐行阅读，是比较吃力的。事实上，代码的编写是有一定的思路的，总的来说，可以把其中的内容分类为以下几块。 创建实体：提供一个实体，后续的一切操作都围绕着这个实体来进行 系统底层组件：添加基本功能组件，这些组件的源码无法看到，仅暴露可调用的函数 tag：打上标签，主要用于对Prefab进行分类，方便系统对特定类的Prefab进行操作 StateGraph和Brain：在Prefab的初始化中一般分别只有一句，用于设置对应的StateGraph和Brain Component：添加组件，与系统底层组件的区别在于可以看到源码。 监听：设置对事件或者世界状态（比如是否月圆之夜，白天还是晚上）的监控，当触发特定事件或者进入某个状态后，执行相应的操作 其它设置：其它个性化的配置 除了必须以「创建实体」作为第一句代码外，其它的部分一般来说并没有严格的顺序限制。要加什么，完全取决于你希望这个Prefab长什么样，能做什么，在这一点上是非常自由的。在联机版中，客机的数据需要从主机同步，许多场景的数据，比如人物的血量、饱食度等，都是来自Component的。因此，在客机中，Component是不需要添加的，即使强行添加，也不会被使用。类似的还有StateGraph和Brain。因此，在联机版的Prefab定义中，通常会有以下这段代码 if not TheWorld.ismastersim then return inst end 这段代码的意思是，检查当前系统环境是否是主机。如果不是主机，就到此为止，不再执行后面的代码。在这段代码之前的部分，是主客机通用的，通常只包含创建实体，添加系统底层组件，添加tag。 虽然代码的编写顺序没有严格的限制，但官方的代码多数是按照上面的顺序来编写的，其中添加StateGraph和Brain的代码通常只有一句，通常写在component的部分之前。有一个例外是locomotor，根据官方代码给出的注释，这个component需要在添加StateGraph之前就添加。 联机版的典型代码的示例如下 local function fn() -- 创建实体 local inst = CreateEntity() -- 添加系统底层组件 inst.entity:AddTransform() ... -- 添加tag inst:AddTag(\"xxx\") ... -- 主客机分割代码 if not TheWorld.ismastersim then return inst end -- 添加locomotor组件，并设置速度 inst:AddComponent(\"locomotor\") inst.components.locomotor.runspeed = xxx -- 添加StateGraph inst:SetStateGraph(\"SGxxx\") -- 添加Brain inst:SetBrain(brain) -- 添加其它Component并设置初始化参数 inst:AddComponent(\"xxxx\") inst.components.xxx.xattr = \"xxx\" ... -- 注册监听和回调 inst:ListenForEvent(\"event_name\", callback_fn) ... -- 其它设置，通常是封装好的一系列预处理内容 MakeHauntablePanic(inst) ... return inst end 下面就分块来讲解这些代码，这里选用的示例Prefab是rabbit，代码在prefabs/rabbit.lua。它不像猪人、蜘蛛那样有多种形态写在同一个Prefab文件里，整体代码结构比较清晰，以上讲到的部分都有涉及，代码量适中（整个脚本共300～400行），是很好的学习参考对象。 创建实体 实体创建只有一行代码：local inst = CreateEntity()，由此得到一个inst变量，它代表着Prefab初始化的实体，后续的所有操作，无论是添加组件还是tag，都需要围绕这个实体来进行。 在这个部分，顺带讲讲CreateEntity的具体执行内容和inst对应的类 CreateEntity是定义在lua脚本代码里的，可以在mainfunctions.lua下面找到，定义如下 function CreateEntity() local ent = TheSim:CreateEntity() local guid = ent:GetGUID() local scr = EntityScript(ent) Ents[guid] = scr NumEnts = NumEnts + 1 return scr end EntityScript这个类的定义，则可以在entityscript.lua里找到，上面初始化构建EntityScript的实例时传入的ent,可以通过inst.entity调用。 根据上面代码可以看到，我们得到的inst实际上是用lua脚本定义出来的EntityScript类的一个实例，对真正实体的一个封装。真正的实体是通过系统底层的函数TheSim:CreateEntity来创建的。当我们要使用系统底层的组件时，必须通过这个真正的实体去调用。因此，在添加底层组件的时候，使用的是这样的的格式:inst.entity:AddXXX()，这里的inst.entity就是真正的实体。 为什么会做这样的设计呢？这是因为系统底层返回的entity所拥有的函数是比较有限的，要添加或者修改都比较麻烦。在进行entity层面上的修改时，会很不方便。比如添加Component这个工作：Component是直接用lua定义的，自然地，要添加Component也需要通过lua来完成。这中间会涉及到一些重复的，相对有点复杂度的处理，会希望抽象提取成一个函数，也就是AddComponent。希望能通过inst直接调用这个函数，而系统底层返回的entity又不方便直接修改。因此，使用EntityScript来做一层封装，在EntityScript这个类中定义AddComponent,从而实现inst:AddComponent('xxx')这样简洁的调用。 系统底层组件 系统底层组件，指的是那些和Component有类似用法，但定义代码被封装编译在游戏引擎内部，我们无法看到具体源码的部分。相比于数量接近400个的Component，在官方代码中出现的系统底层组件较少，只有近30个，其中被大量使用的也不到10个。使用底层组件而不是Component的原因可能有很多，每一个决策都有其依据。比较常见的理由是，组件需要非常频繁调用底层系统的其它资源，比如控制动画、声音的播放，或者控制entity的位置变化等，这样的情况下，封装在底层系统，可以有效地提升游戏性能。 在这个部分，代码可以再细分成两部分：添加组件和设置初始化参数。 具体代码示例如下 inst.entity:AddTransform() inst.entity:AddAnimState() inst.entity:AddSoundEmitter() inst.entity:AddDynamicShadow() inst.entity:AddNetwork() inst.entity:AddLightWatcher() MakeCharacterPhysics(inst, 1, 0.5) inst.DynamicShadow:SetSize(1, .75) inst.Transform:SetFourFaced() inst.AnimState:SetBank(\"rabbit\") inst.AnimState:SetBuild(\"rabbit_build\") inst.AnimState:PlayAnimation(\"idle\") 添加组件的代码比较简单，每个组件单独添加，格式统一为inst.entity:Add{组件名}() 然后是设置初始化参数，格式统一为inst.{组件名}:调用函数(参数列表...)。比如inst.DynamicShadow:SetSize(1, .75)，就是调用了在设置「动态影子」组件DynamicShadow，使用SetSize函数来设置影子的大小。 并不是所有的组件都需要做初始化。比如Network组件，是负责主客机通信的，只有在主客机之间发生数据交流时才被使用，不需要设置初始化参数。 MakeCharacterPhysics(inst, 1, 0.5)这一句代码，实际上是一个封装好的Physics组件初始化函数，代码可以在standardcomponents.lua下找到。这个函数的含义是为entity添加一个Physics组件，并设置一系列的初始化参数，构成一个生物的物理效果。 问题在于，看不到源码的情况下，怎么确定都有哪些系统组件可用，每个组件都有哪些函数呢？如果完全没有其它内部资料，唯一的手段就是从官方源码来学习。通过对官方源码的全方位分析，可以发现共使用了29个不同的底层组件， 其中调用添加的次数在20以上的常用组件如下，了解这些组件如何使用就可以了。 Transform: 控制空间位置变换 AnimState: 控制动画播放 Physics: 物理引擎，控制碰撞体形状和大小，以及运动状态等 Network: 控制网络数据传输 SoundEmitter: 控制声音播放 MiniMapEntity: 小地图图标 DynamicShadow: 控制影子 Light: 控制光照 LightWatcher: 监控光照强度 其中物理引擎的部分与其它组建不同，具有标准化的特点：同一类物体都用同一套初始化参数，比如MakeCharacterPhysics不仅仅用在rabbit上，也用在玩家角色、猪人和鱼人上。因此，一般都会使用官方自己写好的标准组件函数来完成初始化，而不是一条条地调用Physics组件函数。 系统底层组件，以及下面会谈到的Component，是Prefab里最主要的组成部分，它们决定了一个Prefab有什么功能，每个功能具体如何与系统进行交互。要详细列出来每个组件的用法，篇幅会比较巨大，因此这部分内容会单独写一篇文章来进行介绍。 Tag tag，其实就是一个标记，用于区分一类Prefab，让系统能够针对性地对这一类Prefab作出反应。比如在人物的初始化函数里，都会添加「player」tag，这样在进行一些判定的时候，就可以通过检测这个标记，来有效地筛选出属于玩家的实体。举例来说，玩家死后变成幽灵，丢失「player」，换成了「playerghost」，与世界的互动方式也会变成「作祟」。这就是通过检测tag来区分给出不同的动作。类似的还有蜘蛛不会主动攻击韦伯，是因为蜘蛛不会对有「spider」tag的生物发起攻击。 在做Prefab初始化的时候，主要是根据需要添加相应的tag，可以通过inst:AddTag('xxx')来添加。 rabbit的tag相关代码如下 inst:AddTag(\"animal\") inst:AddTag(\"prey\") inst:AddTag(\"rabbit\") inst:AddTag(\"smallcreature\") inst:AddTag(\"canbetrapped\") inst:AddTag(\"cattoy\") inst:AddTag(\"catfood\") inst:AddTag(\"cookable\") 一般来说，如果自己做Mod，有定位类似官方生物的，比如我的《Samansha》人物Mod里的鹿，定位和羚羊相似，则应该添加相同的tag。官方给出的许多tag，都能从名字上直观地看出来是有何含义，会用在什么场景，尽量保持Tag一致，有利于在游戏中取得一致的系统反馈。 到tag为止，往下的代码都只在主机中执行。 StateGraph和Brain 关于SG和Brain，在第一篇中已有简略介绍，本篇重点也不在于此，因此不做过多的重复。 在Prefab的初始化中，与SG和Brain相关的部分就是为Prefab设置SG和Brain，代码非常简单，如下几句 local brain = require(\"brains/rabbitbrain\") inst:SetStateGraph(\"SGrabbit\") inst:SetBrain(brain) 一般SG和Brain视情况添加。 SG：如果所构建的Prefab有较复杂的动画转换，或者就是和某个官方生物使用同一套动画骨架，则需要设置SG。 Brain：如果希望这个Prefab有一定复杂度的自主智能，能自动判断什么情况下做什么，则应该添加Brain。 Component 和系统底层组件类似，区别在于定义的代码都是可以直接在components文件夹下的同名lua文件看到。Component相比于底层组件，数量多得多，有将近400个，为Prefab提供了丰富多样的功能。 添加Component的代码形如inst:AddComponent(\"{component_name}\")，调用相应的组件函数则是形如inst.components.{component_name}:{fn_name}(args) 比如让rabbit可以吃东西，就写了以下代码 inst:AddComponent(\"eater\") inst.components.eater:SetDiet({ FOODTYPE.VEGGIE }, { FOODTYPE.VEGGIE }) 这两句代码的意思是，添加eater这个Component，让rabbit具备吃食物的能力。然后通过SetDiet函数来设置rabbit能吃哪些种类的食物。 Component这部分的代码，参考官方的写法，每添加一个Component就接着写相应的初始化，这一点与系统组件先添加全部再初始化不同。这是因为Component的组件数量很多，而且更改也相对频繁，将添加的代码与初始化代码放在一起，更方便管理。 在rabbit中，总共添加了如下几个Component locomotor：提供移动能力 eater: 提供吃东西的能力 inventoryitem: 可以装进玩家的物品栏 sanityaura: 可以影响周围生物的sanity cookable: 可以用于烹饪 knownlocations: 能够记住位置，这里主要是用于能够找到自己家的洞穴 health: 拥有血量 lootdropper: 会掉落物品 combat: 可以战斗 inspectable: 可以被检查 sleeper: 可以睡觉 tradable: 可以用于交易 burnable: 会着火 freezable: 会结冰 hauntable: 可以被作祟 perishable: 会腐坏 因为内容过多，不会讲解每个component的细节，主要谈谈以下几个函数，他们都是来自standardcomponents.lua，可以通过这一个函数来完成相应目的的配置。推荐在遇到类似的需求时，使用官方提供的这些函数，可以避免因版本变动引起的bug。 MakeSmallBurnableCharacter: 能着火，适用于小型生物，类似的还有MakeMediumBurnableCharacter,MakeLargeBurnableCharacter，分别是和中型和大型生物，下面的Freezable也类似 MakeTinyFreezableCharacter: 能结冰 MakeHauntablePanic: 能被作祟，被作祟后会逃开 MakeFeedableSmallLivestock: 能被喂食，并且长期不喂食会死掉 监听 所谓监听，就是当满足特定条件的时候，执行某些动作。比如rabbit到了冬天会换成白色的冬兔外貌，被攻击了之后会迅速逃跑到最近的洞穴里，这些变化都是通过监听做到的。 监听的实现方式多种多样，通常来说，只需要一个合适的触发器(Trigger)，以及设定一个在满足条件触发时要执行的回调函数(Callback Function)即可。 在Prefab的初始化定有中，常用的触发器有两个： 对世界状态的监听: WatchWorldState，当世界进入某一个特定的状态时，执行回调函数 对自身事件的监听: ListenForEvent，当自己触发了某个事件时，执行回调函数 在rabbit中的实际应用如下 对世界状态的监听 WatchWorldState的代码链路比较深，可以这样找到：初始化函数->OnInit->OnWake 这段代码的含义是，监听世界的状态是否是冬天。如果是冬天，会切换成冬兔形态，如果是其它季节，会切换成普通兔子的形态。 local function OnIsWinter(inst, iswinter) if inst.task ~= nil then inst.task:Cancel() inst.task = nil end if iswinter then if not IsWinterRabbit(inst) then inst.task = inst:DoTaskInTime(math.random() * .5, BecomeWinterRabbit) end elseif IsWinterRabbit(inst) then inst.task = inst:DoTaskInTime(math.random() * .5, BecomeRabbit) end end inst:WatchWorldState(\"iswinter\", OnIsWinter) 对自身事件的监听 通过inst:ListenForEvent来设定事件触发器，第一个参数是触发的事件，第二个参数是回调函数。 这串代码的含义是当rabbit自身被攻击的时候，会触发一个attacked事件，然后执行这个回调函数，rabbit就会往自己家的洞穴跑。如果距离自己家太远，找不到回家的路的话，就不会再跑了。 local function OnAttacked(inst, data) local x, y, z = inst.Transform:GetWorldPosition() local ents = TheSim:FindEntities(x, y, z, 30, { \"rabbit\" }, { \"INLIMBO\" }) local maxnum = 5 for i, v in ipairs(ents) do v:PushEvent(\"gohome\") if i >= maxnum then break end end end inst:ListenForEvent(\"attacked\", OnAttacked) 其它设置 其它所有不归属于上面几个模块的都归属于此，这个部分就是各种个性化的处理了，每个Prefab都大不相同。此处介绍一点技巧：inst:DoTaskInTime在初始化中的应用。 在很多Prefab的初始化函数里，都可以找到类似的语句: inst:DoTaskInTime(0, OnInit)，这是为实体做特定的初始化，OnInit就是初始化函数。之所以会这样写，而不是直接执行OnInit，是因为经过DoTaskInTime的封装，OnInit可以在生成Entity，完成初始化后再执行。有人可能会说，把OnInit放在最后执行就可以了。实际上并非如此，在执行完初始化函数之后，还有一些后续处理，才算真正完成了初始化。这样的操作可以保证某些参数设置绝对完整，比如说不会出现要调用的Component没有添加的情况。如果有某些特别的初始化需求，可以仿照这样的操作来进行。比如rabbit里的这个初始化函数，在生成后会判断是冬天还是夏天，如果是冬天，会等5秒后变为冬兔，这个过程需要执行一个等待5秒的task，如果在初始化函数中设置，可能会因为各种原因导致无法执行。 结语 prefab的主要目的就是提供生成entity的模板，其中最重要的部分是初始化函数。初始化函数中的代码可以分为这几个部分：创建实体、系统底层组件、tag、SG和Brain、Component、监听和其它设置。希望本篇文章能够为各位同学在阅读Prefab代码时提供一些思路。下期会讲解饥荒游戏中最核心的部分——组件，包括系统组件和Component。Prefab解释了各种物体是如何构建的，组件则为这些物体提供了丰富多样的功能。 "},"main/c3_component_and_action.html":{"url":"main/c3_component_and_action.html","title":"第三章 组件与动作","keywords":"","body":"引言 在开始本篇内容之前，先来思考一个小问题：抛开代码，仅仅从游戏本身的视角来看，猪人与玩家有什么相同点和不同点？相同点：都有血量、都能移动和战斗、都能戴帽子、都能吃东西等等；不同点：猪人没有精神值，可以徒手砍树，无法装备武器等等。这些相同点和不同点，都是一些属性或者功能，这就引出了今天要介绍的内容：如何为entity添加各种功能，又如何让这些功能与游戏世界里的其它entity进行交互，产生影响。要解答这些问题，就需要弄清楚两个概念：组件和动作。 定义 「吃东西」是一个很基础的能力，玩家都能吃东西，猪人、蜘蛛等生物也可以。我们就以「吃东西」为例子来进行讲解。一个完整的进食流程如下 首先，通过某种方式，触发动作。这些方式可以抽象出来，称为「动作触发器」。触发器有很多，只需要其中一个满足条件触发就可以进入下一环节。 触发之后，会进行动作判定和执行环节。在action里。每一个动作都有一个自己的执行函数，记作fn，用于调用相应的组件来执行功能，比如在「吃东西」这个流程中，会调用吃东西的生物的eater组件，执行Eat函数，进食带来的效果，比如提升饱食度或者血量，也会在这个函数中执行。最后会返回进食执行的结果——成功还是失败。根据结果不同，可能会执行不同的后续操作。比如如果执行成功，生物会进入进食状态，播放相应的进食动画等等。 相关代码片段如下，位于actions.lua 这段代码的意思是，会检测要吃的东西和执行吃的动作的生物是否分别具备相应的组件edible和eater，如果符合要求则执行eater的Eat函数。soul和souleater的判定属于wortox特有，是另一种形式的进食，处理逻辑是相似的，这里略过。 ACTIONS.EAT.fn = function(act) local obj = act.target or act.invobject if obj ~= nil then -- 要吃的东西得有edible组件，要进食的生物得有eater组件 if obj.components.edible ~= nil and act.doer.components.eater ~= nil then return act.doer.components.eater:Eat(obj, act.doer) -- wortox 特有的进食方式 elseif obj.components.soul ~= nil and act.doer.components.souleater ~= nil then return act.doer.components.souleater:EatSoul(obj) end end end eater的Eat函数代码如下，它详细定义了要吃东西的各种细节。因为代码较长，以注释的形式来逐行解读。 function Eater:Eat(food, feeder) -- food指食物，feeder为喂食者，如果喂食者不存在，则设置为进食者 feeder = feeder or self.inst -- 判断是否可以进食，比如女武神不能吃蔬菜就在这一步判断 if self:PrefersToEat(food) then -- 记录堆叠数量，eater的eatwholestack属性设置为True的话，会一次吃掉所有的食物，这会出现在诸如春、秋季BOSS身上。 -- 常规情况下，eatwholestack=False，一次只会吃一个食物。如果你希望打造一个「贪吃」特色的人物，可以把eatwholestack设置为True，每次进食都会吃完整个堆叠的食物。 local stack_mult = self.eatwholestack and food.components.stackable ~= nil and food.components.stackable:StackSize() or 1 -- 下面这一段和woody吃木头有关系，吃木头只会加木头值，不影响其它属性 local iswoodiness = false if self.inst.components.beaverness ~= nil then -- 获取木头制增量 local delta = food.components.edible:GetWoodiness(self.inst) if delta ~= 0 then -- 调用beaverness组件来增加相应的木头值 self.inst.components.beaverness:DoDelta(delta * stack_mult) iswoodiness = true end end -- 此段是真正的进食影响三项基本属性的代码，如果是吃木头则略过判定 if not iswoodiness then -- 计算进食效果倍率，默认为1 local base_mult = self.inst.components.foodmemory ~= nil and self.inst.components.foodmemory:GetFoodMultiplier(food.prefab) or 1 -- 执行health变化代码。如果食物会扣血的，还需要检测进食者+食物是否符合扣血要求 -- health,hunger和sanity的计算方法都类似，下面的代码不再额外说明 if self.inst.components.health ~= nil and (food.components.edible.healthvalue >= 0 or self:DoFoodEffects(food)) then -- 实际变化量 = 食物基础变化量 * 进食效果倍率 * 进食者的吸收率 local delta = food.components.edible:GetHealth(self.inst) * base_mult * self.healthabsorption if delta ~= 0 then -- 执行实际的血量变化 self.inst.components.health:DoDelta(delta * stack_mult, nil, food.prefab) end end -- 执行hunger变化代码，类似health的过程 if self.inst.components.hunger ~= nil then local delta = food.components.edible:GetHunger(self.inst) * base_mult * self.hungerabsorption if delta ~= 0 then self.inst.components.hunger:DoDelta(delta * stack_mult) end end -- 执行sanity变化代码，类似health的过程 if self.inst.components.sanity ~= nil and (food.components.edible.sanityvalue >= 0 or self:DoFoodEffects(food)) then local delta = food.components.edible:GetSanity(self.inst) * base_mult * self.sanityabsorption if delta ~= 0 then self.inst.components.sanity:DoDelta(delta * stack_mult) end end end -- 如果有喂食者，则触发喂食者相关的细节，这里是触发了一个feedincontainer事件，后续处理由事件的监听回调完成。 if feeder ~= self.inst and self.inst.components.inventoryitem ~= nil then local owner = self.inst.components.inventoryitem:GetGrandOwner() if owner ~= nil and ( owner == feeder or (owner.components.container ~= nil and owner.components.container.opener == feeder) ) then feeder:PushEvent(\"feedincontainer\") end end -- 进食者触发oneat事件 self.inst:PushEvent(\"oneat\", { food = food, feeder = feeder }) -- 如果有设置进食者的进食回调函数，则会执行。 if self.oneatfn ~= nil then self.oneatfn(self.inst, food) end -- 如果有设置食物的进食回调函数，则会执行。 if food.components.edible ~= nil then food.components.edible:OnEaten(self.inst) end -- 吃掉的食物在此处会被移除 if food:IsValid() then --might get removed in OnEaten... if not self.eatwholestack and food.components.stackable ~= nil then food.components.stackable:Get():Remove() else food:Remove() end end -- 记录进食时间 self.lasteattime = GetTime() if self.inst.components.foodmemory ~= nil then self.inst.components.foodmemory:RememberFood(food.prefab) end -- 返回True，说明进食动作顺利完成了，会影响到后续的处理 return true end end 执行完进食的过程后，会在最后返回进食是否成功，继而执行不同的后续操作。比如进食成功会播放相应的进食动画，失败了的话，人物就会说话提示。 整个动作的过程，可以抽象出三个模块，分别是 component-组件：记录属性，提供方法。它定义了一个方法/功能与系统的逻辑交互细节，角色的数值变化和系统交互主要由component完成。 action-动作：判定动作是否能执行，并调用相应的component来完成。它决定了一个动作该如何调用component与环境发生交互。 动作触发器：通过任意动作触发器，让实体执行动作过程。 接下来分模块进行解读 component-组件 先来给出组件的定义：与特定的功能主题具有高度关联性的一套行为和属性的集合。 在代码上，component被定义成一个class，不同的component属于不同的class。每个component都可以围绕着这个component的功能主题来定义的一系列属性和方法。 一个典型的component定义代码如下 -- 这个是下文中会用到的处理属性变化的函数 local function oncaneat(xxx)... end -- 定义组件名称，Class的三个参数分别为构建函数、父类（一般留空，component不继承）、属性变化处理的table local Eater = Class(function(self, inst) self.inst = inst -- 各项属性初始化设置 self.eater = false ... self.sanityabsorption = 1 end, nil, -- component属性变化时，client端的处理。这涉及到主客机网络编程的问题，暂时不谈 { caneat = oncaneat, }) -- 定义组件的方法 function Eater:Eat(food, feeder) ... end function Eater:OnRemoveFromEntity() ... end function Eater:SetDiet(caneat, preferseating) ... end return Eater 以eater这个component来做说明。除了「Eat」以外，还提供了其它的操作。比如设定能吃的食物类型、设定进食时产生的额外效果等等，我们把这些统称为「行为」，在代码中则是设置相应的函数。还可以设置各项属性，如食物的吸收效率，进食时的特殊效果等。通过设置各项属性，可以让同一个功能在不同的prefab上产生不同的效果。比如每个人物的可食用物品不同，产生的食物效果不同等等。 eater是一个典型的侧重「行为」的component，也就是说它的函数操作主要用于描述一个「行为」产生的效果，比如进食会调用饱食度的组件hunger，让hunger来执行饱食度的提升。而我们很熟悉的饱食度、精神值等，也有相应的组件hunger,sanity，是侧重「属性」的组件，它们的函数操作主要用于描述组件内属性的变化，比如通过函数直接更改角色的饱食度。一个组件可以全是行为，也可以全是属性，甚至仅仅是一个空壳都可以，只要是合理抽象而且能与世界交互就行。比如定义一个「无情铁手」的组件，希望拥有这个组件的人物可以徒手伐木和碎石。那么，不需要为组件设置任何属性和方法。只要定义好对应的动作和触发器，就可以实现这一过程。待讲完动作和触发器后，再来说明一下这个小功能该如何实现。 在上一篇我们也提到了系统底层组件，它的使用模式和功能定位和component很像，所以也可以归为组件，作为基础功能，被广泛嵌套应用在各种代码中。与component的区别在于，系统底层组件封装在游戏底层引擎中，无法看到定义的源码，要使用和理解这些组件，只能学习参考官方源码中使用了相关组件的代码。另外，它们本身无法关联到相应的动作，也不能直接获取属性，只能调用函数。 action-动作 action定义了如何调用组件进行互动，以及决定了如何算是动作执行成功或失败。在实际的代码中，一般会先通过Action类构建一个具体的动作，传入一些动作的相关参数，比如优先级、执行距离、骑乘/幽灵状态是否可用等等。然后再设置它的执行函数fn，这个函数中的代码会描述如何调用component来完成动作流程。 代码参考如下，位于actions.lua 所有的action都会写进一个全局变量的table:ACTIONS ACTIONS = { ... EAT = Action({ mount_valid=true }) ... } ACTIONS.EAT.fn = function(act) ... end 动作触发器 前面提到，动作触发器有很多。粗略分类可以分为两种，一是由玩家通过游戏界面触发，比如右键点击采花，二是由生物AI自行触发。本篇主要讲解一，至于二的部分，留待以后讲解生物AI时再一并说明。 动作可以通过玩家的游戏界面触发，比如装备上了斧头后能够右键砍树，或者右键点击物品栏中的食物就能自动进食。这一点依赖于动作触发器-ComponentAction。它把component和action联系了起来：将一个component与特定场景关联，在执行函数中设置满足某些条件后允许角色执行某个动作，那么角色就可以执行这个动作。注意有时候可能会出现同时满足多个动作的执行条件，这时候会按照优先级取最高的来执行。 系统定义的场景有5个，分别使用不同的参数 SCENE：参数inst, doer, actions, right。这一场景指的是在游戏主界面上对着实体的操作。比如右键点击收获浆果。 USEITEM：参数inst, doer, target, actions, right。这一场景是选取一件物品，再点击地图上的东西或装备栏的物品，比如给篝火添加燃料 POINT：参数inst, doer, pos, actions, right。这一场景指的是对地图上任意一点执行的操作，比如装备传送法杖后，你可以右键点击地板，传送过去。 EQUIPPED：参数inst, doer, target, actions, right。这一场景指的是装备了一件物品后，可以实施的操作，比如装备斧头后可以砍树。 INVENTORY：参数inst, doer, actions, right。这一场景是点击物品栏执行的操作。比如右键点击物品栏里的木甲，就会自动装备到身上。 ISVALID：参数inst, action, right。这个不是定义的场景，是用于检测动作是否合法的，我们可以忽略它。 以上场景各自的操作是不同的，一个组件可以在每个场景中分别定义其执行函数，并连接不同的动作。比如，edible这个组件是用于表明一个物品是可食用的。这个可食用的物品，可以选取后点击地图上的鸟来喂鸟，也可以在物品栏里直接点击右键食用，同一个组件分别绑定了USEITEM和INVENTORY两个不同的场景。 上面几个场景都有参数，同名的参数含义是一样的，这些参数会传入执行函数中。 inst: 指拥有对应组件的物品。当场景参数没有target时，一般指的就是鼠标点击的目标。当场景参数有target时，在USEITEM中指的是你选取的物品，在EQUIPPED中指的是你装备的物品。 doer: 指执行动作的角色，通常是玩家 actions：指动作序列，在执行函数中，要添加一个动作XXX，就是执行代码table.insert(actions, ACTIONS.XXX) target：指执行动作的目标，比如给篝火添加燃料时，篝火就是target。这个target既可以是地图上的某个东西，也可以是物品栏里的某个物品 pos：指地图上某一点，比如传送法杖指定的传送位置。 right：是否使用右键来执行动作，如果要使用右键，这个值为True，只有当玩家点击右键时才会执行。如果使用左键，则可以在执行函数的定义中省略这个传入参数。 让我们来看看代码是怎么写的。ComponentAction的定义代码位于componentactions.lua中的COMPONENT_ACTIONS变量。它定义了官方的所有场景、组件与动作的连接。这里主要是展示不同的场景下，组件如何连接动作的，关键在于了解原理，所以会选择几个执行函数比较简单的组件。 ... local COMPONENT_ACTIONS = { -- 注意每个场景传入参数的数量和顺序都是固定的，只有最后一个right参数可以看情况省略。请参考每个场景里，官方添加的args注释， SCENE = --args: inst, doer, actions, right { ... -- 蜂箱、蘑菇农场都有这个组件 harvestable = function(inst, doer, actions) -- 检测目标是否拥有harvestable标签 if inst:HasTag(\"harvestable\") then -- 满足条件后，将HARVEST动作插入actions序列中即可 table.insert(actions, ACTIONS.HARVEST) end end, ... } USEITEM = --args: inst, doer, target, actions, right { ... -- 睡袋的组件，可以让人物进入睡眠状态 sleepingbag = function(inst, doer, target, actions) -- 睡袋要对着玩家自己使用，并且不能处于失眠和睡着的状态。 if doer == target and doer:HasTag(\"player\") and not doer:HasTag(\"insomniac\") and not inst:HasTag(\"hassleeper\") then table.insert(actions, ACTIONS.SLEEPIN) end end, ... } POINT = --args: inst, doer, pos, actions, right {... } EQUIPPED = --args: inst, doer, target, actions, right {... } INVENTORY = --args: inst, doer, actions, right {... } ISVALID = --args: inst, action, right {... } } ... replica component中储存了大量的玩家属性数据，比如饱食度，精神度等等。为了保证数据一致性，这些数据都是储存在主机(server)中的，从触发动作到最后产生属性变化，整个计算过程也是在主机中完成。但是，其他玩家(client)也有获取调用这些数据的需求，比如玩家的UI界面需要显示饱食度的具体数值，就需要读取数据。但是客机上又不储存这个数据，怎么办呢？原始的做法是，每当要调用数据的时候，就发送一个请求给主机，然后主机会返回一个网络变量，读取这个变量就可以了。但这样的处理方式在代码上不够优雅，会让整体布局变得凌乱。因此，专门针对component的属性，就派生出了replica。replica可以存在于client中，是component的同态附加。每当数据发生变化，就可以通过replica进行同步，这就大大简化了component主体部分的代码，可以让component的主体部分只关心游戏逻辑本身，而把网络数据传输的部分放在replica中。 大部分component都不需要在client中存在，因为不需要读取相应的数值，这里也只是略作说明，让大家有个基本了解。更详细的介绍，我会放在后面的文章里，和网络编程的部分一起讲解。 结语 entity是灵魂，prefab是骨架，component是血肉。正是不同的component提供了大量的功能，才使得整个游戏世界的交互变得丰富多彩。如果你希望深入了解游戏机制，那就需要好好地阅读不同的component。 "},"main/c4_stategraph.html":{"url":"main/c4_stategraph.html","title":"第四章 动起来 - 状态图","keywords":"","body":"引言 玩家在进行各种活动的时候，会播放相应的动画。有些动画可以被打断，比如玩家攻击时有个明显的抬手动作，如果在砍下去之前执行了其它操作，攻击的动画就会被中断，也不会对目标造成伤害。而另一些动画，比如进食，是不可打断的，强制处于硬直状态。另外，在动画播放到某个时间点后，还会开始播放音效。这些变化、硬直，其底层的逻辑结构就是一个StateGraph。我们可以把攻击、移动、进食等等动作各自看成是一个独立的状态(state)，在这个状态下，会播放相应的动画和音效，然后通过某些触发条件将这些state连接起来。这就构成了一个有联系的状态图(StateGraph)。一个拥有状态图的角色，在任何一刻，必定处于其中一个状态中。这样一来，角色就能够动起来了。不仅玩家如此，其它能够行动的猪人、蜘蛛也都是如此。 StateGraph概览 StateGraph，直接翻译过来叫「状态图」，在游戏编程中有类似的概念，叫「状态机」，但这两者还是有一些区别的，状态图允许通过多种方式从任意状态跳转到指定状态，而状态机则是有固定的跳转路线。 图能带来更直观的感受，让我们来看一下状态图是怎样的：下面是我们的好伙伴猪人的状态图。 方形的结点都是一个state，每个state会自动执行一段动画，部分还会添加音效，并且会设定在特定的时间点让部分功能生效。比如attack这个state，会在进入state后的第13帧（1帧=1/30秒）触发攻击效果，这意味着猪人的攻击前摇为13帧。 两个特殊的椭圆形结点，分别是动作和事件处理器。当以某种形式触发了角色的动作或者事件，就会进入相应的处理器流程，如果当前角色的状态满足处理流程的条件，就会将角色转为对应的state。比如触发了猪人砍树的动作，那么就会检测猪人当前是否处于busy的state，如果没有，就会让猪人进入chop的state，接着就会执行砍树的动作。 在结点之间的线，就是相应的触发事件或动作。在state之间转换的线，上面的字代表进入下一个state需要触发的事件（多数都是animover，也就是动画播放结束）。如果是从动作处理器转换的，则代表着相应的触发动作。如果是从事件处理器转换的，线代表着对应事件。部分情况下，同一个事件或动作可能有多个转换的分支，具体会流转到哪，取决于分支条件。 然后我们再来看看代码层面，来自文件stategraphs/SGpig.lua 一份典型的SG代码类似如下结构。 -- 添加commonstates模块，当需要用CommonStates添加一些通用的state时 require(\"stategraphs/commonstates\") local actionhandlers = {... } local events = {... } local states = {... } -- 这里的CommonStates是通用类，方便快速添加一些通用的state，比如idle, frozen等 CommonStates.AddXxxStates(states, {.. }) ... return StateGraph(\"pig\", states, events, \"idle\", actionhandlers) 从StateGraph的构造参数就可以看出来，它的组成部分如下 name:SG的名称，这里是pig，并不要求与prefab一致，因为可能有多个prefab共用一个SG states:所有state结点定义信息，每个结点都是一个table，记录一个状态的全过程中每个环节的操作，主要处理的内容是动画音效的播放、系统交互逻辑的瞬时生效（比如攻击命中扣血）、流程结束后的状态转换等。 events:事件处理器集合。每一个事件处理器在触发了相应事件并满足条件的情况下，会直接将角色转换为特定状态。 defaultstate:每次进入游戏时，默认初始化的状态 actionhandlers:动作处理器。和事件处理器类似，但触发的是动作。 以上的states,events,actionhanlders中的元素分别为对应的类State, EventHandler, ActionHandler对象，包括StateGraph类在内，这几个类的定义代码都可以在stategraph.lua中查看。接下来我们逐个根据代码来做进一步的讲解。 State的构造 State类明面上只有一个传入参数，就是args。实质上这个args默认为一个table，承载了许多参数。 args.name:字符串，state的名称 args.onenter:函数，在进入state时执行的代码 args.onexit:函数，在转换state前执行的代码 args.onupdate:函数，在系统推进更新状态时执行的代码（实质上也就是系统时间发生跳动，每1/30秒跳动一次，这样的跳动称之为1帧） args.ontimeout:函数，在timeout时执行的代码 args.tags:table，其中的元素是字符串。sg标签集，仅限于sg使用，与inst的tag有区别，部分tag可通用。 args.events:table，其中的元素是EventHandler对象。事件处理器列表，在当前状态下如果触发了相应事件，会执行事件对应的回调函数。需要注意的是只是执行函数，并不一定会跳转状态。比如走路时处罚移动的事件，可能只是播放一下走路的音效而已。 args.timeline:table，其中的元素是TimeEvent对象。这个类很简单，第一个参数是time，表示定位在哪一帧。官方提供了常量FRAMES表示1帧的时间，通常的传入的参数是x*FRAMES，表示从进入状态开始过了x帧。第二个参数是fn，也就是在这一帧内要执行的代码，比如播放音效、触发特定效果等等。这个table不需要手动排序，系统会自动根据time的大小重新排序，保证每一帧都能按顺序执行相应代码。 代码结构大致如下 State{ name = \"xxxx\", tags = { \"a\", \"b\", \"c\" }, onenter = function(inst, item)... end, onexit = function(inst)... end, ontimeout = function(inst)... end, onupdate = function(inst)... end, timeline = {... }, events = {... }, } 除了name是必须的外，其它的都可以不填，通常大多数state会有tag和onenter，其它参数根据需要使用。 仍然以猪人为例，我们来看看猪人的进食state State{ -- name是必填项 name = \"eat\", -- tags中含有busy，意味着这个state在流程走完之前，通常不会被打断，除非是遇到被攻击之类的强制打断事件 tags = { \"busy\" }, -- onenter决定了进入状态时要执行什么， onenter = function(inst) -- 让角色停止移动 inst.Physics:Stop() -- 角色播放进食的动画 inst.AnimState:PlayAnimation(\"eat\") end, -- timeline可以精准控制时间轴上的代码执行 timeline = { -- 在第10帧，执行代码 TimeEvent(10 * FRAMES, function(inst) -- 执行缓存中的动作的fn。要转换到进食这个状态，需要有进食的动作，因此这里的动作就是进食 inst:PerformBufferedAction() end), }, events = { -- 当动画播放完后会触发animover事件，并执行相应的回调函数 EventHandler(\"animover\", function(inst) -- 角色的状态跳转到idle inst.sg:GoToState(\"idle\") end), }, }, Handler的构造 Handler的中文学名叫句柄，这个翻译太难理解，我更愿意称之为处理器。Handler的作用就是，监听特定的内容，当出现该内容时，执行预先设计好的代码。在SG中有两种Hanlder，分别是EventHandler和ActionHandler。 EventHandler有两个参数，分别是要监听的事件event和相应的回调函数fn。它的作用就是指定一个要监听的事件，当监听到目标身上有触发该事件时，执行相应的函数。如果EventHandler是写在某个state的events中，则只有当角色处于在该state下才会进行监听。如果是写在StateGraph的envents中，则在任意情况下都会进行监听。触发监听的事件本身并不会直接导致状态转换，要实现状态转换，需要在回调函数中执行相应的代码inst.sg:GoToState(\"xxx\") ActionHandler则有三个参数，分别是action 触发动作, state 转换状态, condition 条件。其中第三个参数condition在实际使用中几乎没有出现，可以忽略。 根据第二个参数state的数据类型不同，ActionHandler有两种处理流程。当state是字符串时，这个参数必须是角色定义好的state之一。当角色触发了指定的action，他就会自动转换为对应的state。当state是一个函数时，函数的返回值必须是一个字符串，也得是state。在函数的形式下，就可以灵活设置不同的返回state，创造state转换的分支。 总结 本期主要说明在游戏中，角色的动画、音效变化是如何实现的。StateGraph不仅仅控制着动画、音效的转变，还决定着具体功能逻辑执行的确切时间点。最容易理解的概念就是人物的攻击前摇，是由相应的attack state的timeline来决定攻击生效的具体时间点的。在简单的Mod中，通常都不会涉及SG相关的内容。但如果你想要更进一步，创造新的动作表现形式，或者修改人物的攻击频率等等，就必须深入了解SG，学习如何构建state和handler。 "},"main/c5_brain.html":{"url":"main/c5_brain.html","title":"第五章 思想 - 让生物拥有智慧","keywords":"","body":"引言 在游戏中大大小小的生物，都有着自己的行为模式：兔子见到人会逃跑，你要是一直追着它，还会进洞；各种有攻击性的怪物比如蜘蛛、猎狗等，看到玩家会主动攻击。这些行为模式是如何实现的呢？一个生物，该如何判断在什么场景下进行何种行为？一个很自然的想法是，给生物内置一个持续运行的程序，也就是所谓的人工智能。只要生物能够体现出一定的行为模式，都可以称之为人工智能。强大的人工智能可以做到下围棋赢下世界第一的棋手，但那样需要消耗大量的计算资源。在游戏中通常不需要那么复杂的人工智能，也不需要那么复杂的计算。重点在于，让生物能够应对外部环境，根据条件做出不同的反应。在游戏领域中，最简单的人工智能当属状态机(State Machine)，和上一期介绍的StateGraph很相似，其实某种意义上，StateGraph也可以看作是一种人工智能。浆果丛被采集了，就换个外观，然后等几天后再变回来，再次可供采集。如果是冬天，就停止生长。这样的一系列逻辑也是对外在环境的反应。但是，如果希望生物的智能更高一些，状态机能处理的情况就有限了。因为状态机是需要基于状态节点来构建的，而实际上生物的行为非常复杂，而且还有许多判断条件和动作优先级问题，状态机使用起来就很不方便。最大的问题是，需要编写大量的状态跳转代码。在这个游戏中，人工智能是通过行为树来实现的。在游戏编程领域中，这是一种非常经典的人工智能编程模型，很多游戏引擎比如UE4,Unity等都内置了这一模型。下面我会先介绍行为树的基本概念，再来展开讲讲这个游戏中的行为树是如何实现的。 概览 让我们从一个简单的例子开始：兔子。兔子的行为比较简单，一般我们容易感知到的是：靠近兔子它就会跑，如果追得紧了还会进洞。如果把兔子能吃的食物放进陷阱里，兔子也会过去吃掉然后被捕获。兔子完整的行为逻辑如下所示，系统会从左往右，依次向下遍历整个行为树节点，直到其中一个节点返回SUCCESS或RUNNING，或者全部节点都执行过一遍。 遍历流程步骤大致如下 如果被作祟了，兔子会Panic(感到慌乱，到处乱跑) 如果受到了火焰伤害，兔子也会Panic 兔子会逃离一定范围内最近的带有scarytoprey标签的生物，这个标签不仅存在于玩家身上，也存在于阿比盖尔的姐姐和一些怪物身上。具体的逃离规则比较复杂，我们把这个带scarytoprey标签的生物称为hunter，兔子会根据hunter与自己的距离来判断，在距离太近时就会逃跑，距离太远时会停下。 同样是RunAway，与3的区别在于，逃跑时会回家（返回洞穴）。设计成两个RunAway我猜测是如此考虑的：3的逃离（不回家）检测范围比较小，4的逃离（回家）检测范围比较大，也就是说，如果兔子远远地看到了hunter，它就会直接往洞钻。但如果hunter移速过快或者使用了瞬移，在兔子还没反应过来的时候就已经逼近安全距离，此时直接钻洞里很可能会被逮住，这时候兔子就会往先往远离hunter的方向逃跑，而不是钻洞。 如果接收到了gohome的事件，会直接回家 如果时间到了晚上，会直接回家 如果时间到了春天，会直接回家 进食。一定的条件下，兔子会吃掉附近的食物。 漫游。兔子会在洞穴附近游荡。 每隔一段时间，这个流程都会按以上顺序重新执行。默认间隔是1秒，兔子的设置是0.25秒，其它生物则有不同的设置，常用的就是0.25,0.5,1这三个间隔。执行间隔越短，对系统资源的消耗也就越大，但生物的反应决策也越快，在实际的使用中，可以根据需要进行调整。 由上面的例子可以看出，行为树是以行为节点（Panic,RunAway,DoAction,Wander等)作为结束点来构建的，通过遍历的形式来持续决策：如果一个行为不满足执行条件，返回了FAILED，就会继续访问下一个行为节点，直到有一个行为节点返回了SUCCESS或者RUNING，或者访问完所有节点，一轮遍历结束后稍等一会又重新开始。通过在行为节点上游添加一些额外的控制节点，就可以实现一些更复杂的调度情况，比如增加一些行为的前置条件，或者逆转行为的结果等等，甚至可以允许平行执行多个动作，直到所有动作都完成。 状态 在行为树中，最基本的概念是节点的状态，业界中复杂的行为树可能拥有很多不同的状态，但在这个游戏中，只有四种基本状态。 READY：节点的默认状态，当节点被重置后会设置为该状态。 SUCCESS：表明动作执行完成并且成功了，产生了相应的动作效果。 FAILED：表明动作执行中断，失败了，没有产生动作效果。 RUNNING：表明动作还在执行中，需要继续等待 子节点的状态会影响到父节点的状态，依父节点的访问逻辑决定。 节点 在行为树中，依据子节点数量的多少，节点可以分为三类 组合节点：拥有不定数量的子节点，通过某种逻辑来从子节点的状态确定自身节点的状态。可以实现较为复杂的子节点组合控制。 修饰节点：拥有一个子节点。可以通过设置条件来决定是否访问子节点，以及根据子节点的访问状态来确定自身的状态。 行为节点：没有子节点，是逻辑执行的最终端，在这一层上往往会处理具体的游戏逻辑。 接下来让我们更进一步，分别看看每种节点的细节，加深理解。 组合节点 组合节点拥有若干个子节点。通过设置访问顺序的逻辑，可以实现多种变换。 最简单的形式就是按顺序访问子节点，直到其中一个节点返回RUNING或FAILED。这样可以保证brain可以按顺序执行一整个动作序列，直到序列动作完成，或者其中一个动作失败。最顺利的情况是，依序访问子节点，第一个子节点返回SUCCESS后，继续访问第二个，依此类推，直到结束。然而，某些子动作节点需要较长时间的操作，比如攻击行为，攻速较慢的情况下，可能会超过brain的刷新间隔，这种情况下，子动作节点在刷新期间返回的是RUNNING，直到动作完成，子动作节点状态变为SUCCESS或FAILED之前，每次刷新后，brain都会直接从访问这个子节点开始，这就保证了每次刷新之间的动作连贯性。第三种情况是，因为某些原因，比如攻击动作丢失了目标，导致子动作节点FAILED了，后续的动作也无法再执行，这时候节点状态就转为FAILED，所有子节点状态重置，在下一轮检测中从头开始。 更复杂一点的形式，是根据情况选择。比如想要攻击某个目标，最简单的情况下，就是走过去，直到进入攻击范围，展开攻击。但如果路上有一堵墙，导致自己无法移动到攻击范围内，那么就应该先破坏墙，再进行攻击。抽象出来，就是完成一件事，有若干种不同的方法来应对不同的场景，在不确定实际场景状况的情况下，可以按一定顺序尝试使用不同的方法，直到完成目标或者失败。 还有一种情况是，动作需要反复执行，比如猪人砍树，要执行多次直到树被砍到。有时候，几个动作还会同时执行，比如一边干活，一边说话。 以上提到的几种不同的形式，都有相应的组合节点可以使用，以应对不同的需求。总的来说，可以把组合节点理解为：根据需要，以特定顺序访问子节点。多数情况下，如果子节点在RUNING，组合节点会等待该子节点的状态变为SUCCESS或FAILED，在此期间，组合节点的状态也是RUNNING。 修饰节点 修饰节点只拥有一个子节点，可以理解为对这个子节点的一种拓展，用于在子节点执行前或执行后进行一些额外的处理。 最常见的修饰就是设置条件，只有在满足某种条件的情况下，才会访问子节点执行动作。比如，如果设置一个玩家AI，可以设置当他饱食度低于50%时才会尝试进食。还可以附加一些其它的操作，比如在执行动作的同时，记录一些信息，或者让角色说话。另一方面，还可以对子节点的状态进行修改，比如SUCCESS切换成FAILED。 修饰节点在游戏中有大量的使用，这是为了实现解耦：动作节点只需要关心如何执行具体的动作，而其它的部分，比如何时执行动作，动作执行前后的处理等等，就可以交给修饰节点来进行，从而使得代码的使用更为灵活。 行为节点 行为节点没有子节点，它本身就是执行的最终端，负责处理实际的游戏逻辑。比如进食，砍树，漫游，回家等等，都会直接调用相应的组件来执行游戏逻辑交互。游戏提供了一个通用的行为节点，可以设置函数来完善细节。如果动作比较复杂，在一个检测周期内可能无法完成，就需要另外定义新的行为节点，游戏里也定义了一些常用的行为节点，比如破坏墙壁、漫游等等，逻辑相对复杂或者执行时间较长，需要记录状态。 游戏实现 让我们来看看兔子的brain代码，看看在代码层面上，brain是如何实现的，相关源码的位置在brains/rabbitbrain.lua，前面的代码都是一些初始化内容和函数定义，只需要看最后OnStart函数定义的部分即可 ... -- 兔子的AI定义 local RabbitBrain = Class(Brain, function(self, inst) Brain._ctor(self, inst) end) ... -- 在这个函数下定义兔子的行为树 function RabbitBrain:OnStart() -- 这个root就是完整的行为树定义部分，PriorityNode下，这个table的每一个元素，都对应上文行为树图中的一条线。 local root = PriorityNode( { -- 条件修饰节点，被作祟后执行Panic，此处的Panic就是个行为节点 WhileNode( function() return self.inst.components.hauntable and self.inst.components.hauntable.panic end, \"PanicHaunted\", Panic(self.inst)), -- 条件修饰节点，受到火焰伤害后执行Panic WhileNode( function() return self.inst.components.health.takingfiredamage end, \"OnFire\", Panic(self.inst)), -- 动作节点，逃跑 RunAway(self.inst, \"scarytoprey\", AVOID_PLAYER_DIST, AVOID_PLAYER_STOP), -- 动作节点，还是逃跑 RunAway(self.inst, \"scarytoprey\", SEE_PLAYER_DIST, STOP_RUN_DIST, nil, true), -- 修饰节点，触发事件后执行回家的动作 EventNode(self.inst, \"gohome\", DoAction(self.inst, GoHomeAction, \"go home\", true )), -- 条件修饰节点，如果不是白天，执行回家的动作 WhileNode(function() return not TheWorld.state.isday end, \"IsNight\", DoAction(self.inst, GoHomeAction, \"go home\", true )), -- 条件修饰节点，如果到了春天，执行回家的动作 WhileNode(function() return TheWorld.state.isspring end, \"IsSpring\", DoAction(self.inst, GoHomeAction, \"go home\", true )), -- 动作节点，吃东西 DoAction(self.inst, EatFoodAction), -- 动作节点，在自己的洞附近漫游 Wander(self.inst, function() return self.inst.components.knownlocations:GetLocation(\"home\") end, MAX_WANDER_DIST) }, .25)-- 每0.25秒刷新检测 self.bt = BT(self.inst, root) end return RabbitBrain 从上面的代码可以看出，每一个brain都是先构建Brain的一个子类，然后重新定义这个类的OnStart函数。在这个函数中，定义一个root变量，这个变量是用PriorityNode构建的，行为树的相关设置定义就从这个PriorityNode展开。最后执行代码self.bt = BT(self.inst, root)收尾。 如果你想了解不同的生物的行动逻辑，可以先找到这个Prefab的定义文件，再查看它设置的brain名称，在同名的brain文件下找到对应的OnStart函数，在这个函数下的代码就是生物的行动逻辑了。 总结 生物的AI是通过设置brain来得到的，而brain是通过行为树来构建的。想要深入理解生物的行动逻辑，就需要细致地解读brain定义的行为树，并且了解每个行为树节点的用途。为此，我也列出了官方定义的全部行为树节点的详细解释。 "},"reference/system.html":{"url":"reference/system.html","title":"系统组件","keywords":"","body":"AnimState 负责控制角色的外观和动画，人物执行不同的动作会播放不同的动画，佩戴某些装备会改变外观，以及改变视觉上的大小，甚至计量条的变化等。凡是和物体形态变化有关的，都由AnimState来操作实现。 fn 用途 传入参数 返回值 AddOverrideBuild 添加覆盖Build，比如给鸟笼添加鸟的build。对于骑乘类，这个函数很重要 附加的build 无 AnimDone 判断动画是否播完 无 bool 是否播完 AssignItemSkins 为物品设置皮肤 user_id 用户id，剩余参数不定，分别是各个部位的皮肤名 无 BuildHasSymbol ClearAllOverrideSymbols ClearBloomEffectHandle ClearOverrideBuild ClearOverrideSymbol 清除指定标记点的覆盖 inst_symbol 要清除覆盖的标记点 无 ClearSymbolExchanges CompareSymbolBuilds FastForward GetAddColour GetBuild GetCurrentAnimationFrame GetCurrentAnimationLength 获取当前动画的长度 无 length 动画长度 GetCurrentAnimationTime 获取当前动画停留在第几秒 无 time 停留位置 GetCurrentFacing GetInheritsSortKey GetMultColour 获取角色的r,g,b,a 无 r,g,b,a 同SetMultColour的输入参数 GetSkinBuild GetSortOrder GetSymbolPosition Hide 隐藏某个部分，和Show搭配使用 part 部分 无 HideSymbol IsCurrentAnimation 检测当前播放的动画是否为指定的动画 anim 动画名 无 OverrideItemSkinSymbol OverrideMultColour OverrideShade OverrideSkinSymbol OverrideSymbol 覆盖某个标记点，常见于装备武器后，手上就出现了一把武器。 inst_symbol 要覆盖的标记点 ;swap_build 用于替换的build ;swap_symbol 用于替换的build上的标记点 无 Pause PlayAnimation 播放指定名称的动画，会立刻中断当前动画的播放 anim 动画名; loop 是否重复，可省略，默认值是fasle 无 PushAnimation 将指定动画推送到播放序列中，当前动画播放完后会接着播放这个动画，常见于要通过一组动画来表现人物的场景 anim 动画名; loop 是否重复，可省略，默认值是fasle 无 Resume SetAddColour 设置附加颜色 r,g,b,a四个参数，分别对应红，绿，蓝的颜色值以及透明度。取值均在[0,1]之间。对于透明度，取0时就是完全透明。 无 SetBank 设置指定的动画组。玩家站在地上和骑在牛上，使用的是两套不同的动画，就是通过设置不同的Bank来实现的 bank 动画组名 无 SetBankAndPlayAnimation SetBloomEffectHandle 设置Bloom效果的处理器 path 处理器路径 无 SetBuild 设置指定的外观。比如兔子有夏、冬两种形态，就是通过设置不同的Build来实现的 build 外观名 无 SetClientSideBuildOverrideFlag SetClientsideBuildOverride SetDeltaTimeMultiplier SetDepthBias SetDepthTestEnabled SetDepthWriteEnabled SetErosionParams SetFinalOffset 不确定，根据函数名猜测，是设置动画的帧偏移量。 offset 动画偏移量，可以设置为负数。 无 SetFloatParams SetHaunted SetHighlightColour SetInheritsSortKey SetLayer 设置图层，图层是有固定的摆放顺序的，比如土地是最下一层，然后农场是中间层，农场里的作物是最上层。在构建一些多层结构的东西时，都需要设置图层。 layer 图层变量，这里使用定义于constants.lua中的全局变量，LAYER_BACKGROUND/LAYER_WORLD/LAYER_WORLD_BACKGROUND/LAYER_WORLD_CEILING/LAYER_FRONTEND 无 SetLightOverride SetManualBB SetMultColour 设置角色的r,g,b,a，也就是三个颜色+透明度。可以通过这个函数来让角色变得透明 r,g,b,a四个参数，分别对应红，绿，蓝的颜色值以及透明度。取值均在[0,1]之间。对于透明度，取0时就是完全透明。 无 SetMultiSymbolExchange SetOceanBlendParams SetOrientation 设置刚体轴方向。不同的轴方向会影响看到的视觉效果，比如池塘看起来是贴着地面的，就是因为设置了这一参数为ANIM_ORIENTATION.OnGround direction 方向，这里使用定义于constants.lua中的全局变量，ANIM_ORIENTATION下的各个值 无 SetPercent 设置动画百分比，对于一些通过动画帧来表现数值的物品很有用。比如雨量计，实际上是设置了一个动画，从0到100%，然后根据实际数值设置相应的百分比 anim 动画名; percent 百分比 无 SetRayTestOnBB SetScale 设置缩放比例 length_scale 长度缩放;width_scale 宽度缩放 。取值填小数，如果是负数，则是相应的方向颠倒。 无 SetSkin SetSortOrder 设置排序优先级，常与SetLayer配套使用，当有多个物品重叠时，优先级高的排在前面。 priority 优先级，整数 无 SetSortWorldOffset SetSymbolExchange SetTime 设置动画停留在第几秒 time 停留位置 无 Show 展示某个部分，通常和Hide搭配使用。比如，装备武器时，会隐藏ARM_normal，显示ARM_carry，人物的手就发生了变化 part 部分 无 ShowSymbol DynamicShadow 负责管理物体的影子。每个物体的影子都各不相同，甚至同一个角色，在不同的装备下也有不同的效果。大家可以试试装备不同的雨伞观察一下影子的变化。 fn 用途 传入参数 返回值 SetSize 设置影子大小 length_scale 长度缩放;width_scale 宽度缩放 。取值填小数。 无 Enable 设置是否有影子 取值 ture/false 无 EnvelopeManager 信封管理？不太确定 fn 用途 传入参数 返回值 AddColourEnvelope AddFloatEnvelope AddVector2Envelope Follower 在component中也有一个同名的follower，但这个系统组件的follower是更底层的，常用于一些特效跟随的处理。而component的follower更侧重于一个生物跟随另一个生物。 fn 用途 传入参数 返回值 FollowSymbol 跟随标记，常用于特效跟随于某个物体。 target_guid 跟随目标的guid;symbol 跟随的标记点; x,y,z 在三个方向上的偏移量 无 SetOffset FontManager 字体管理 fn 用途 传入参数 返回值 RegisterFont Label 标签 fn 用途 传入参数 返回值 Enable SetColour SetFont SetFontSize SetText SetUIOffset SetWorldOffset Light 负责管理光源，可以为一个物体添加光源并调整设置相关参数如发光半径、强度、衰减度等。 fn 用途 传入参数 返回值 Enable 设置光源是否可用 取值 ture/false 无 EnableClientModulation 待定，未确认用途 GetCalculatedRadius 获取光源半径 无 radius 半径距离 GetColour 获取光源颜色 无 r,g,b 分别对应红，绿，蓝的颜色，取值[0,1] GetDisableOnSceneRemoval GetFalloff GetIntensity GetRadius IsEnabled 判断光源是否可用 无 取值 ture/false SetColour 设置光源颜色 r,g,b 分别对应红，绿，蓝的颜色，取值[0,1] 无 SetDisableOnSceneRemoval SetFalloff 设置衰减强度 falloff 衰减强度,取值[0,1] 无 SetIntensity 设置光源亮度 intensity 亮度,取值[0,1] 无 SetRadius 设置光源半径。在很多涉及光的计算中都会用到光源半径，比如作物生长需要光源，这个光源是有距离要求的，太远的就不算。 radius 半径距离 无 LightWatcher 光照监视器，观测光照的情况。在游戏中，很多动植物的活动都和光照有关。例如蜘蛛一般情况下只在晚上和黑暗环境下活动，猪人则在白天或者明亮的环境下活动。如何判断黑暗和明亮，就是光照监视器来做的。 fn 用途 传入参数 返回值 GetLightAngle 获取光照角度 无 angle 光照角度 GetLightValue 获取光照值 无 light_val 光照值 GetTimeInDark GetTimeInLight 获取光照时长 无 time 光照时长 IsInLight 判断是否在明亮环境 无 取值 ture/false SetDarkThresh 设置黑暗阈值 thresh 阈值，取值[0,1] 无 SetLightThresh 设置明亮阈值 thresh 阈值，取值[0,1] 无 Map 地图 fn 用途 传入参数 返回值 SetMinimapOceanEdgeColor0 IsVisualGroundAtPointDebug GetTileCenterPoint SetMinimapOceanEdgeParams1 SetOceanTextureBlendAmount SetMinimapOceanEdgeNoiseParams GetIslandAtPoint InternalIsPointOnWater GetNodeIdAtPoint SetWaterfallFadeParameters GetRandomPointsForSite GetStringEncode SetOverlayColor2 SetImpassableType CalcPercentLandTilesAtPoint SetOceanTextureBlurParameters SetClearColor Finalize IsVisualGroundAtPoint CanTerraformAtPoint SetNavSize IsDeployPointClear SetSize CanDeployMastAtPoint FindRandomPointInOcean GenerateBlendedMap GetTileAtPoint GetWorldSize GetNearestPointOnWater SetOverlayColor1 ResetVisited SetOceanNoiseParameters0 SetMinimapOceanEdgeFadeParams SetWaterfallNoiseParameters0 CalcPercentOceanTilesAtPoint GetPlatformAtPoint SetUndergroundRenderLayer SetOverlayLerp SetMinimapOceanEdgeShadowParams AddRenderLayer IsPassableAtPointWithPlatformRadiusBias IsSurroundedByWater CanDeployRecipeAtPoint IsOceanAtPoint RegisterGroundTargetBlocker GetNavStringEncode CanDeployAtPointInWater Replace IsFarmableSoilAtPoint IsOceanTileAtPoint CanDeployAtPoint IsGroundTargetBlocked GetEntitiesOnTileAtPoint CanTillSoilAtPoint CanDeployWallAtPoint SetOceanEnabled RepopulateNodeIdTileMap CanDeployPlantAtPoint SetPhysicsWallDistance CanPlantAtPoint IsAboveGroundAtPoint TileVisited CanPlowAtPoint IsValidTileAtPoint CollapseSoilAtPoint CanPlaceTurfAtPoint SetMinimapOceanEdgeShadowColor RegisterDeployExtraSpacing RegisterTerraformExtraSpacing IsPassableAtPoint VisitTile RetrofitNavGrid SetMinimapOceanTextureBlurParameters SetOceanNoiseParameters2 GetNodeIdTileMapStringEncode SetMinimapOceanEdgeParams0 SetMinimapOceanEdgeColor1 SetUndergroundFadeHeight GetSize SetOverlayColor0 SetOceanNoiseParameters1 SetTransparentOcean Fill GetTileCoordsAtPoint SetNodeIdTileMapFromString SetTileNodeId GetTileXYAtPoint GetTile SetNavFromString SetWaterfallNoiseParameters1 SetMinimapOceanMaskBlurParameters SetTile SetOverlayTexture FindNodeAtPoint SetFromString NodeAtPointHasTag RebuildLayer IsPointNearHole CanPlacePrefabFilteredAtPoint MapExplorer 地图探索 fn 用途 传入参数 返回值 ActivateLocalMiniMap EnableUpdate LearnAllMaps LearnRecordedMap RecordAllMaps RecordMap RevealArea MapLayerManager 地图涂层管理 fn 用途 传入参数 返回值 CreateRenderLayer ReleaseRenderLayer SetMinimapColor SetPrimaryColor SetSampleStyle SetSecondaryColor SetSecondaryColorDusk MiniMap 小地图 fn 用途 传入参数 返回值 AddAtlas AddRenderLayer ClearRevealedAreas ContinuouslyClearRevealedAreas DrawForgottenFogOfWar EnableFogOfWar IsVisible RebuildLayer SetEffects ShowArea ToggleVisibility MiniMapEntity 负责管理小地图的图标 fn 用途 传入参数 返回值 CopyIcon SetCanUseCache 待定，设置可使用缓存 是否可用,取值ture/false 无 SetDrawOverFogOfWar 待定，设置可无视迷雾显示图标 是否可用,取值ture/false 无 SetEnabled 设置小地图图标是否可用 是否可用,取值ture/false 无 SetIcon 设置小地图图标 image 图标文件名 无 SetIsFogRevealer 待定，设置可以显示迷雾 是否可用,取值ture/false 无 SetIsProxy SetPriority 设置优先级，高优先级可以显示在更上面 priority 优先级，整数 无 SetRestriction Network 负责管理网络 fn 用途 传入参数 返回值 GetNetworkID GetUserID GetUserFlags GetPlayerColour IsPlayingWithFriends IsBorrowed GetClientName AddUserFlag 待定，无法判断 SetConsecutiveMatch IsConsecutiveMatch SetPlayerEquip SetPlayerSkin SetPlayerAge SetClassifiedTarget 待定，无法判断 RemoveUserFlag 待定，无法判断 IsServerAdmin GetPlayerAge Pathfinder 寻路 fn 用途 传入参数 返回值 AddWall GetPathTileIndexFromPoint GetSearchResult GetSearchStatus HasWall IsClear KillSearch RemoveWall SubmitSearch Physics 管理物体的物理运动相关的内容，包括物理参数，移动，碰撞等。 通常而言，不建议自己配置物理运动相关的参数，错误参数可能造成一些诡异的物理效果。最好使用官方给出的预设函数来一键配置，位于standardcomponents fn 用途 传入参数 返回值 CheckGridOffset ClearCollidesWith ClearCollisionMask ClearLocalCollisionMask ClearMotorVelOverride ClearTransformationHistory CollidesWith 设置可以触发碰撞的类型 collision_type 碰撞类型，这里使用定义在constants.lua下的全局变量，COLLISION表下的内容 无 ConstrainTo GeoProbe GetCollisionGroup GetCollisionMask GetHeight GetMass GetMotorSpeed GetMotorVel GetRadius GetVelocity IsActive IsPassable SetActive SetCapsule 待定 SetCollides SetCollisionCallback SetCollisionGroup 设置自身的碰撞类型 collision_type 碰撞类型，这里使用定义在constants.lua下的全局变量，COLLISION表下的内容 无 SetCollisionMask SetCylinder SetDamping SetDontRemoveOnSleep SetFriction SetLocalCollisionMask SetMass 设置物体的质量，会影响到一些物理效果 mass 物体质量 无 SetMotorVel 为物体设置一个移动速度 x,y,z 物体在三个方向上的移动速度,其中,x是物体在地面上朝向方向，y是垂直地面向上的方向，z是与x在地面上正交的方向 无 SetMotorVelOverride SetRestitution SetRigidBodyEnabled SetSphere SetTriangleMesh SetVel 待定，需要实测代码确定和motorvel的不同 x,y,z 物体在三个方向上的移动速度,其中,x是物体在地面上朝向方向，y是垂直地面向上的方向，z是与x在地面上正交的方向 无 Stop TEMPHACK_DisableSleepDeactivation Teleport 瞬移到指定位置 x,y,z 要传送位置的三维坐标 无 TeleportRespectingInterpolation PostProcessor 色彩特效相关 fn 用途 传入参数 返回值 SetColourCubeData SetColourCubeLerp SetColourModifier SetDistortionFactor SetDistortionRadii SetEffectTime SetLunacyEnabled SetOverlayBlend SetOverlayTex SetPostProcessingEnabled RoadManager 道路管理 fn 用途 传入参数 返回值 AddControlPoint AddSmoothedControlPoint BeginRoad GenerateQuadTree GenerateVB IsOnRoad SetStripEffect SetStripTextures SetStripUVAnimStep SetStripWrapMode SoundEmitter 负责声音控制，播放物体本身拥有的音效资源。 fn 用途 传入参数 返回值 GetEntity KillAllSounds KillSound 停止播放指定音效 sound 音效名 无 OverrideVolumeMultiplier PlaySound 播放指定音效 path 音效文件路径 无 PlaySoundWithParams 带着参数播放音效 path 音效文件路径,param_tbl 参数表，形如{param_a=xxx,param_b=xxx} 无 PlayingSound 判断是否在播放指定音效 sound 音效名 is_playing 是否在播放该音效，取值为true 或 false SetMute SetParameter 设置音效参数，可能会影响某些音效的播放效果 sound 音效名;param 参数名;value 参数值 无 SetVolume 设置音量 sound 音效名;volume 音量 无 Transform 管理物体的位置、大小、方向等。其中「大小」与AnimState有区别的地方在于，AnimState设置的大小是视觉上的大小，而Transform则是实际上的大小，会影响到物体的碰撞等相关物理效果。 fn 用途 传入参数 返回值 GetFacing GetLocalPosition GetPredictionPosition GetRotation 获取物体的朝向 无 degree 朝向角度，取值范围[0,360] GetScale 获取物体的缩放比例 无 x,y,z 物体在三个方向上的缩放比例 GetWorldPosition 获取物体的当前世界坐标 无 x,y,z 物体的三维坐标 SetEightFaced SetFourFaced 设置物体有四个面，会影响物体在相应朝向时展示的形态。四个面就是每个面占90度。其它类似的还有SetNoFaced(1面),SetTwoFaced(2面),SetSixFaced(6面),SetEightFaced(8面) 无 无 SetFromProxy 不确定，猜测是设置所有参数同步于proxy，一般常见于各种特效，同步于对应的附加物上 proxy_guid 常用的写法是传入proxy变量，然后取proxy.GUID 无 SetIsOnPlatform SetNoFaced SetPosition 设置物体的世界坐标，可以让物体瞬移到指定位置 x,y,z 物体的三维坐标 无 SetRotation 设置物体的朝向 degree 朝向角度，取值范围[0,360] 无 SetScale 设置物体的缩放比例 x,y,z 物体在三个方向上的缩放比例 无 SetSixFaced SetTwoFaced UpdateTransform VFXEffect 特殊音效管理 fn 用途 传入参数 返回值 AddParticle AddParticleUV AddRotatingParticle AddRotatingParticleUV ClearAllParticles EnableBloomPass EnableDepthTest EnableDepthWrite FastForward GetNumLiveParticles InitEmitters SetAcceleration SetBlendMode SetColourEnvelope SetDragCoefficient SetFollowEmitter SetGroundPhysics SetIsTrailEmitter SetKillOnEntityDeath SetLayer SetMaxLifetime SetMaxNumParticles SetRadius SetRenderResources SetRotateOnVelocity SetRotationStatus SetScaleEnvelope SetSortOffset SetSortOrder SetSpawnVectors SetUVFrameSize SetWorldSpaceEmitter WaveComponent 海浪组件 fn 用途 传入参数 返回值 Init SetWaveEffect SetWaveMotion SetWaveParams SetWaveSize SetWaveTexture TheInputProxy 全局变量，控制输入 fn 用途 传入参数 返回值 AddVibration ApplyControlMapping CancelMapping EnableInputDevice EnableVibration FlushInput GetInputDeviceCount GetInputDeviceName GetInputDeviceType GetLastActiveControllerIndex GetLocalizedControl GetOSCursorPos HasMappingChanged IsAnyControllerActive IsAnyControllerConnected IsAnyInputDeviceConnected IsInputDeviceConnected IsInputDeviceEnabled LoadControls LoadCurrentControlMapping LoadDefaultControlMapping MapControl RemoveVibration SaveControls SetCursorVisible SetOSCursorPos StartMappingControls StopMappingControls StopVibration UnMapControl TheInventory 全局变量，与皮肤管理相关 fn 用途 传入参数 返回值 CancelGetAllItems CheckClientOwnership CheckOwnership CheckOwnershipGetLatest GetAllUnlockedAchievements GetClientGiftCount GetCurrencyAmount GetFullInventory GetKleiPointsAmount GetLocalCookbook GetLocalPlantRegistry GetOwnedItemCount GetOwnedItemCountForCommerce GetUnopenedEntitlementItems GetUnopenedItems GetVirtualIAPCurrencyAmount GetWXP GetWXPLevel HasDownloadedInventory IsAchievementUnlocked IsDownloadingInventory LookupSkinname SetAchievementTempUnlocked SetCookbookValue SetItemOpened SetLocalVanityItems SetPlantRegistryValue StartGetAllItems TheNet 全局变量，与网络相关 fn 用途 传入参数 返回值 AddToWhiteList AllowConnections Announce AnnounceDeath AnnounceResurrect AnnounceVoteResult AutoJoinLanServer Ban BanForTime BeginServerModSetup BeginSession CallClientRPC CallRPC CallShardRPC CancelCloudServerRequest CleanupSessionCache DeleteCluster DeleteSession DeleteUserSession DeserializeAllLocalUserSessions DeserializeUserSession DeserializeUserSessionInClusterSlot DiceRoll Disconnect DoneLoadingMap DownloadServerDetails DownloadServerMods EncodeUserPath GenerateClusterToken GetAllowIncomingConnections GetAllowNewPlayersToConnect GetAutosaverEnabled GetAveragePing GetBlacklist GetChildProcessError GetChildProcessStatus GetClientMetricsForUser GetClientTable GetClientTableForUser GetCloudServerId GetCloudServerRequestState GetCountryCode GetCurrentSnapshot GetDefaultClanAdmins GetDefaultClanID GetDefaultClanOnly GetDefaultEncodeUserPath GetDefaultFriendsOnlyServer GetDefaultGameMode GetDefaultLANOnlyServer GetDefaultMaxPlayers GetDefaultPvpSetting GetDefaultServerDescription GetDefaultServerIntention GetDefaultServerLanguage GetDefaultServerName GetDefaultServerPassword GetDefaultVoteEnabled GetDeferredServerShutdownRequested GetFriendsList GetIsClient GetIsHosting GetIsMasterSimulation GetIsServer GetIsServerAdmin GetIsServerOwner GetItemsBranch GetLanguageCode GetLocalUserName GetNetworkStatistics GetPVPEnabled GetPartyChatHistory GetPartyTable GetPing GetPlayerCount GetPlayerSaveLocationInClusterSlot GetServerClanID GetServerClanOnly GetServerDescription GetServerEvent GetServerFriendsOnly GetServerGameMode GetServerHasPassword GetServerHasPresentAdmin GetServerIntention GetServerIsClientHosted GetServerIsDedicated GetServerLANOnly GetServerListing GetServerListingFromActualIndex GetServerListingReadDirty GetServerListings GetServerMaxPlayers GetServerModNames GetServerModsDescription GetServerModsEnabled GetServerName GetServerPVP GetSessionIdentifier GetUserID GetUserSessionFile GetUserSessionFileInClusterSlot GetWorldSessionFile GetWorldSessionFileInClusterSlot HasPendingConnection IncrementSnapshot InviteToParty IsClanIDValid IsConsecutiveMatchForPlayer IsDedicated IsDedicatedOfflineCluster IsNetIDPlatformValid IsNetOverlayEnabled IsOnlineMode IsSearchingServers IsVoiceActive IsWhiteListed JoinParty JoinServerResponse Kick LeaveParty ListSnapshots ListSnapshotsInClusterSlot LoadPermissionLists NotifyAuthenticationFailure NotifyLoadingState OnPlayerHistoryUpdated PartyChat PrintNetwork RemoveFromWhiteList ReportListing Say SearchLANServers SearchServers SendLobbyCharacterRequestToServer SendModRPCToClient SendModRPCToServer SendModRPCToShard SendRPCToClient SendRPCToServer SendRPCToShard SendRemoteExecute SendResumeRequestToServer SendSlashCmdToServer SendSpawnRequestToServer SendWorldResetRequestToServer SendWorldRollbackRequestToServer SendWorldSaveRequestToMaster SerializeUserSession SerializeWorldSession ServerModCollectionSetup ServerModSetup ServerModsDownloadCompleted SetAllowIncomingConnections SetAllowNewPlayersToConnect SetBlacklist SetCheckVersionOnQuery SetClientCacheSessionIdentifier SetCloudServerInitiatorUserId SetCurrentSnapshot SetDefaultClanInfo SetDefaultFriendsOnlyServer SetDefaultGameMode SetDefaultLANOnlyServer SetDefaultMaxPlayers SetDefaultPvpSetting SetDefaultServerDescription SetDefaultServerIntention SetDefaultServerLanguage SetDefaultServerName SetDefaultServerPassword SetDeferredServerShutdownRequested SetGameData SetIsClientInWorld SetIsMatchStarting SetIsWorldResetting SetIsWorldSaving SetLobbyCharacter SetPartyServer SetPlayerMuted SetSeason SetServerPassword SetServerTags SetWorldGenData StartClient StartCloudServerRequestProcess StartServer StartVote StopBroadcastingServer StopSearchingServers StopVote SystemMessage Talker TruncateSnapshots TruncateSnapshotsInClusterSlot TryDefaultEncodeUserPath UpdatePlayingWithFriends ViewNetFriends ViewNetProfile Vote TheShard 全局变量，当前分片，比如地穴就是一个独立分片 fn 用途 传入参数 返回值 GetDefaultShardEnabled GetSecondaryShardPlayerCounts GetShardId IsMaster IsMigrating IsPlayer IsSecondary SetSecondaryLoading StartMigration TheSim 全局变量，游戏系统本身 fn 用途 传入参数 返回值 AbortFileExistsAsync AddBatchVerifyFileExists AdjustFontAdvance AtlasContains CanReadConfigurationDirectory CanWriteConfigurationDirectory CheckPersistentStringExists CleanAllMods ClearAllDSP ClearDSP ClearFileSystemAliases ClearInput CopyLegacySessionToSlot CreateEntity DebugPause DebugPushJsonMessage DebugStringScreen DecodeAndUnzipString DecodeKleiData DownloadMOTDImages DumpMemInfo DumpMemoryStats EnsureShardIndexPathExists ErasePersistentString FindEntities FindEntities_Registered FindFirstEntityWithTag ForceAbort GenerateNewWorld GetAnalogControl GetBuildDate GetClientModsDownloading GetClipboardData GetDataCollectionSetting GetDebugPhysicsRenderEnabled GetDebugRenderEnabled GetDigitalControl GetEntitiesAtScreenPoint GetEntityAtScreenPoint GetFPS GetFileModificationTime GetGameID GetGroundViewDirection GetLightAtPoint GetLocalSetting GetMOTDQueryURL GetModDirectoryNames GetMouseButtonState GetNumLaunches GetNumberOfEntities GetPersistentString GetPersistentStringInClusterSlot GetPosition GetRealTime GetSaveFiles GetScreenPos GetScreenSize GetServerModsDownloading GetSetting GetSoundVolume GetStashedPlayInstance GetSteamAppID GetSteamBetaBranchName GetSteamIDNumber GetStep GetTick GetTickTime GetTimeScale GetUserHasLicenseForApp GetUsersName GetWindowSize GetWorkshopVersion HasEnoughFreeDiskSpace HasPlayerSkeletons HasWindowFocus HideAnimOnEntitiesWithTag Hook IsBorrowed IsDLCEnabled IsDLCInstalled IsDataCollectionDisabled IsDebugPaused IsKeyDown IsLoggedOn IsNetbookMode IsPlaying LoadFont LoadKlumpFile LoadKlumpString LoadPrefabs LoadUserFile LockModDir LogBulkMetric LuaPrint MemTrackerPop MemTrackerPush OnAssetPathResolve OpenDocumentsFolder OpenSaveFolder PauseFileExistsAsync PreloadFile PrintLoadedTextureInfo PrintTextureInfo Profile ProfilerPop ProfilerPush ProjectScreenPos QueryServer QueryTopMods QueryWorkshopModName QueueDownloadTempMod Quit RegisterFindTags RegisterPrefab RemapSoundEvent RenderOneFrame ReportAction RequestPlayerID Reset ReskinEntity SendGameStat SendHardwareStats SendJSMessage SendProfileStats SendUITrigger SetActiveAreaCenterpoint SetAmbientColour SetCameraDir SetCameraFOV SetCameraPos SetCameraUp SetDLCEnabled SetDataCollectionSetting SetDebugCameraRotation SetDebugCameraTarget SetDebugPhysicsRenderEnabled SetDebugRenderEnabled SetErosionTexture SetHighPassFilter SetInstanceParameters SetListener SetLowPassFilter SetMOTDTarget SetMemInfoTrackingInterval SetMemoryTracking SetNetbookMode SetPersistentString SetPersistentStringInClusterSlot SetRenderPassDefaultEffect SetReverbPreset SetSetting SetSoundVolume SetTimeScale SetUIRoot SetVisualAmbientColour SetupFontFallbacks ShouldInitDebugger ShouldPlayIntroMovie ShouldWarnModsLoaded ShowAnimOnEntitiesWithTag SpawnPrefab StartDownloadTempMods StartFileExistsAsync StartWorkshopQuery StashPlayInstance Step StopAllSounds SubscribeToMod ToggleDataProfiler ToggleDebugCamera ToggleDebugPause ToggleDebugTexture ToggleFrameProfiler TogglePerfGraph TryLockModDir TurnOffReverb UnloadAllPrefabs UnloadFont UnloadPrefabs UnlockModDir UnregisterAllPrefabs UnregisterPrefabs UpdateDebugTexture UpdateDeviceCaps UpdateWorkshopMod UserChooseDirectory ValidateHeap VerifyFileExistsAsync VerifyModVersions WorldPointInPoly ZipAndEncodeString "},"reference/component.html":{"url":"reference/component.html","title":"常见Component","keywords":"","body":"常见Component 数量太多, 以后慢慢补充, 如果有兴趣的同学, 也可以私信我帮助完善。 以下是我觉得使用比较广泛的component, 其实有点基础的同学可以自己看代码来理解。 移动: locomotor 劳作: workable, pickable, finiteuses 种植: growable 食用: edible, eater, perishable, hunger, sanity 战斗: combat, weapon,health , aoetargeting（是否可以做出闪避的效果？） 口袋: inventory, inventoryitem, stackable, container, equippable, inspectable 掉落: lootdropper 篝火: fueled, fuel 交易: trader, 状态: burnable, propagator, freezable 检查: inspectable 作祟: hauntable 动物行为 跟随: follower, leader 睡觉: sleeper 产出,生成: spawner, periodicspawner（拉屎）, childspawner 骑: rider 回家: knownlocations, homeseeker 轨迹: entitytracker（大象脚印) 其它 playercontroller timer "},"reference/brain_dec.html":{"url":"reference/brain_dec.html","title":"Brain：修饰和组合节点","keywords":"","body":"装饰或组合节点都有子节点。本身不负责具体的游戏交互动作，而是负责处理子节点访问前后的相关逻辑，比如访问前的判断，访问后的状态修饰等。 DecoratorNode, NotDecorator, FailIfRunningDecorator, FailIfSuccessDecorator 这几个节点都是一脉相承的，就放在一起说明了。 DecoratorNode 正如其名，是个修饰节点，无任何效果，也未直接使用于任何brain中。唯一的用途是作为几个特殊节点的父类，分别是NotDecorator、FailIfRunningDecorator、FailIfSuccessDecorator。这四个节点，都只有一个构建参数child，即子节点，也就是说这几个节点都拥有唯一一个子节点。它们之间的区别在于会根据子节点的状态来调整本身的状态。 DecoratorNode:无论子节点如何，状态均为FAILED NotDecorator：子节点为SUCCESS，自身则为FAILED；子节点为FAILED，自身则为SUCCESS。其它情况子节点状态等同自身状态。 FailIfRunningDecorator：子节点为RUNNING，自身则为FAILED。其它情况子节点状态等同自身状态。 FailIfSuccessDecorator：子节点为SUCCESS，自身则为FAILED。其它情况子节点状态等同自身状态。 ConditionNode 条件节点，构造函数中附带一个function参数，称之为检测函数，每当访问该节点时，会执行检测函数，如果结果为true，则节点状态为SUCCESS，否则为FAILED。这个节点直接使用的场景比较少，通常来说，主要是作为WhileNode或IfNode的一部分，在大部分场景中都是直接使用WhileNode或IfNode。适合使用这个节点的场景是，判定条件后续的动作节点有多个，这种情况下无法使用WhileNode或IfNode，因为它们只有一个node。 ConditionWaitNode 与ConditionNode很相似，唯一的区别在于，检测函数返回false时，节点状态不是FAILED而是RUNNING。这个节点也仅仅是做了定义，并没有在任何brain中被使用。 ActionNode 这个就是一般意义上的动作节点。构建参数为action, name，分别为动作函数和节点名称。在访问该节点时，会执行动作函数，无论执行结果如何，最后节点的状态都是SUCCESS。这个节点适合执行一些不需要记录状态来调整后续操作的情况。比如小鸟飞走，这个动作只需要执行后就可以不再理会，就很适合用ActionNode来承载。 WaitNode 等待节点，构造参数为time，即等待时间。当所经过的时间小于设置的等待时间时，节点状态为RUNNING，否则为SUCCESS。也就是只要访问到这个节点，就需要等待一段时间才可以进行下一步的操作。 SequenceNode 序列节点，主要用途就是按顺序遍历访问子节点。当节点状态不是RUNING时，会从第一个子节点开始遍历，否则就从上一次执行时的RUNING状态的子节点开始。按顺序访问子节点，当子节点状态为RUNING或FAILED时，中断本次运行，节点的状态等同该子节点的状态。如果子节点的状态为SUCCESS，则继续访问下一个子节点。如果整个遍历过程没有中断地全部完成了，则节点状态为SUCCESS。这一节点适合用于执行需要持续执行的动作，它能够记录上一次正在执行的动作，从而保证在多个间隔中保持执行动作的连续性，让一个序列里的所有动作都能按顺序执行完成。 最常见的就是和WaitNode搭配使用，可以在执行某个动作前强制等待一会儿。比如小偷克劳斯会在等待一段时间后自动回复血量。 SelectorNode 选择节点。访问的步骤是和SequenceNode一样的，只是把其中的FAILED和SUCCESS相关的部分对调了。这个节点在被访问到时，如果是RUNING状态，则继续访问上一次访问的RUNING子节点，否则，重新开始按顺序遍历访问全部子节点。直到其中一个子节点的状态为RUNING或SUCCESS，该子节点的状态就等同该节点的状态。如果所有子节点状态都不是RUNING或SUCCESS，则该节点的状态为FAILED。也就是说，这个节点会选择遍历到的第一个状态不是FAILED的节点。举例来说，可以做到这样的效果 用一个实际例子来说明会更容易理解 上图是一个简单的攻击选择器。首先尝试原地攻击，如果目标距离超过攻击范围，则FAILED。然后尝试追逐目标，缩短距离，如果成功缩短距离就SUCCESS，然后重新执行原地攻击。如果检测到有墙体，无法快速接近目标，则FAILED。接着就会访问破墙节点，尝试破坏墙体，成功后重新遍历操作。 这个节点可以处理一些复杂的分支选择，不过目前还未在官方的brain中应用过。 LoopNode 循环节点。和SequenceNode的执行流程是相似的，区别在于增加了循环。节点会一直按SequenceNode的流程访问子节点。当子节点全部访问完成后会重置，重新开始，并且令循环次数+1。 结束循环有两种方式： 访问流程中有子节点返回了FAILED 循环次数达到了预先设置的最大循环次数 如果没有设置循环次数，又没有子节点返回FAILED，则这个循环流程会一直持续下去。 一个常见的例子是猪人砍树。如果你仔细观察，会发现猪人每次砍树的时候都会碎碎念，说一句话，砍一棵树。 RandomNode 从名字来看，是一个随机选择的节点。不过代码看起来有点问题，而且也没有应用于任何brain，忽略这个节点。 PriorityNode 这个节点通常是作为整个brain的根节点来使用的。其访问的流程有多重判断，比较复杂，了解其流程也无助于理解使用，因此就不做细致的讲解了。只需要知道，第一个参数为子节点的table，第二个参数为检测间隔即可，第三个参数常常是不填的，可以忽略。除了作为根节点使用外。也可以作为序列节点使用，类似SequenceNode，额外增加的功能是可以设置独立的检测时间间隔，但不可以高于根节点的间隔，否则根节点会先刷新。 ParallelNode和ParallelNodeAny 两个节点很相似，放在一起说明。ParallelNode正如其名，平行节点，会平行地访问所有的子节点，在每一轮间隔中，都会访问所有状态不为SUCCESS的节点。当其中一个子节点状态为FAILED时，自身状态变为FAILED。当所有的子节点状态都为SUCCESS时，自身状态变为SUCCESS。其它的情况下，自身的状态均为RUNNING。ParallelNodeAny是ParallelNode的子类，FAILED的条件是一样的，区别在于SUCCESS。只要有一个子节点为SUCCESS且没有子节点为FAILED，自身的状态就会变为SUCCESS。 EventNode 事件节点。构造参数有四个，inst, event, child, priority。 inst：要监听事件的目标实体 event：要监听的事件名 child：事件触发时要执行访问的子节点 priority：执行优先级，当有多个EventNode时，会根据优先级来确认先执行哪一个。 这个节点会为inst设置事件的监听回调，当inst触发事件时，执行访问child。常见的用法是，inst自身触发gohome事件，然后child设置的动作为回家。 WhileNode和IfNode 这两个节点很相似，就放在一起说明。首先，这两个所谓的节点并不是真正意义上的节点，实际上是一个构造函数，会返回一个组合好的节点。WhileNode会返回一个ParallelNode，分别含有两个子节点，分别为ConditionNode和要访问的动作节点。IfNode也很相似，区别在于ParallelNode变成了SequenceNode。两个构造函数的参数都是cond,name,node，分别为判定函数，节点名称和动作子节点，这个动作子节点会在判定函数返回true时被访问。两者的区别在于，WhileNode会在每个检测周期开始时，重新进行判定，如果判定不为true，不管子节点当前的的status如何，都会强制FAILED。而IfNode则是一旦判定为true，后续的每个检测周期都会略过判定直接访问子节点，直到子节点的状态变为SUCCESS或FAILED。 简单地说，两者使用的区别就在于你是否希望子节点的执行能被打断。如果你希望不断检测状态来决定是否执行下一步动作，就使用WhileNode。如果你希望判定成功一次后就一直执行下一步动作直到完成或失败，就选择IfNode。两者在游戏中都有大量地使用，让我们来举例说明。比如，生物被作祟或者着火之后会执行Panic动作，是很常见的设置。在这个场景中，我们肯定希望当作祟或者着火状态结束后，生物就不再Panic，这时候就应该使用WhileNode。而另外一个场景，鸟在看到人靠近的时候会直接飞走，在这个场景中，人只要靠近了，不管之后是否离开了检测范围，一旦触发，鸟就会不受打断地直接飞走。在这个场景中，就应该使用IfNode。 以下代码均出自brains/birdbrain.lua，也就是鸟的AI设置，分别使用了WhileNode和IfNode，可以看出它们的区别。 -- 一旦作祟状态结束，Panic就会停止 WhileNode( function() return self.inst.components.hauntable ~= nil and self.inst.components.hauntable.panic end, \"PanicHaunted\", Panic(self.inst)), -- 一旦鸟感知到了危险，就会不受打断地飞走。 IfNode(function() return ShouldFlyAway(self.inst) end, \"Threat Near\", ActionNode(function() return FlyAway(self.inst) end)), LatchNode 锁节点。从代码上看，应该是要锁住brain一段时间。没有想到合适的使用场景，官方代码的brain中也没有用到，略过。 ChattyNode 这个节点虽然算是修饰节点，但是单独定义在一个文件里的，位于behaviours/chattynode.lua。其代码包含游戏逻辑上的互动，在某种意义上也可以算是一个行为节点，但它带有唯一子节点，所以还是归类为修饰节点。 这个节点的作用是，当子节点处于RUNING状态时，会令角色说话，要说的内容可以通过构建函数中的chatlines参数传入。传字符串时，对应的是全局变量STRINGS下的一个key，传table时，则需要其中每个元素都填写完整的说话内容。每次说话后，会有一个随机时长的短暂沉默时间。 MinPeriod 与ChattyNode类似，单独定义在一个文件里，位于behaviours/minperiod.lua。它的作用是，可以周期性地执行访问子节点。常见的使用场景是，为生物执行某中动作设置一个CD，避免其连续执行。比如小偷坎普斯，偷东西是有CD的，不会连续偷取。 "},"reference/brain_action.html":{"url":"reference/brain_action.html","title":"Brain：动作节点","keywords":"","body":"Brain：动作节点 动作节点就是最终执行游戏逻辑的节点，都是叶子节点。除了官方提供的这些，有特殊逻辑需求的，也可以考虑自己自定义。 AttackWall 攻击围墙，构造参数只有一个inst，即要实施动作的角色。这个节点会让角色在一系列判断之后尝试攻击围墙。 AvoidLight 避光，构造参数只有一个inst，即要实施动作的角色。这个节点会让角色尝试躲避光线，并未实际用在任何brain中，但在spier的brain中有require。 BeargerOffScreen 秋季BOSS熊大在离开屏幕后的行为定义。这个节点是专为熊大设计的，在早期的代码中有使用，目前已经废弃，不再使用，所以也无需了解 ChaseAndAttack 追逐并攻击。这个节点的参数inst, max_chase_time, give_up_dist, max_attacks, findnewtargetfn, walk，分别为执行动作的对象， 最大追击时间，最大追击距离，最大攻击次数，寻找新目标的函数，是否走路（否则是跑步）。这个节点会让生物在限定条件下，尝试追逐目标并攻击。这个节点默认的执行流程中，并不包含寻找攻击目标的内容，因此，要么定义findnewtargetfn，要么就通过其它的方式来为生物赋予一个攻击目标。在官方代码中，大多数ChaseAndAttack节点都没有findnewtargetfn，是通过其它方式来实现目标设置的。最常见的就是保持默认设置：生物被攻击后，会把攻击者设置为攻击目标。 ChaseAndAttackAndAvoid 追逐、攻击并躲避。这个节点的参数inst, findavoidanceobjectfn, avoid_dist, max_chase_time, give_up_dist, max_attacks, findnewtargetfn, walk，可以看到基本和ChaseAndAttack类似，区别在于增加了两个参数findavoidanceobjectfn, avoid_dist。也就是这个节点会在追逐攻击的同时，试图躲避某些目标。比如猪人战士，在攻击时回调整自己的攻击位置，避免过于靠近猪王。findavoidanceobjectfn, avoid_dist分别表示找到躲避目标的函数和躲避的距离。 ChaseAndRam 追逐并冲撞。节点参数inst, max_chase_time, give_up_dist, max_charge_dist, max_attacks，分别是生物自身，最大追逐时间，最大追逐距离，最大冲撞距离，最大攻击次数。如果目标与自身的距离超过最大冲撞距离，就无法实行冲撞。这个节点用于秋季BOSS，地下的犀牛BOSS这些具有冲撞能力的BOSS上。 ControlMinions 控制子体。这个节点仅在食人花上使用，控制食人花的子体。它会在子体的控制范围内进行一系列的行动，比如捡起地上的东西或者收获农场的食物等。 DoAction 通用的动作节点。节点参数inst, getactionfn, name, run, timeout，分别是生物自身，获取动作的函数（返回值必须是一个动作），是否在执行动作时跑起来，超时时间。这个节点可以通过设置getactionfn来让生物在满足某些条件的情况下执行特定动作，最常见的就是在某些条件下执行回家的动作。 FaceEntity 面向某个实体。节点参数inst, getfn, keepfn, timeout，分别是生物自身，搜寻目标的函数，保留目标的判断函数，超时时间。这个节点可以让生物面向特定的对象。如果你仔细观察跟随你的生物，你会发现它们在静止时总是面向你的，这就是FaceEntity在发挥作用。 FindClosest 寻找最近的单位。节点参数inst, see_dist, safe_dist, tags, exclude_tags, one_of_tags，分别是生物自身，搜寻距离，安全距离（当搜寻到目标后，会尝试移动到安全距离内），搜寻标签（搜寻单位必须包含全部的标签），排除标签（搜寻单位不能其中的一个标签），其中之一标签（如果这个参数不为空，则可以无视前两个参数，只要单位具有这个参数中的任意一个标签就算是匹配了）。这个节点主要用于寻找符合标签要求的目标，并且自动移动到目标附近。 FindFlower 从名字就可以看出来，这个节点的作用就是寻找花，用于蜜蜂和蝴蝶。 FindLight 寻找光。节点参数是inst, see_dist, safe_dist，分别为生物自身，搜寻距离，安全距离。参数具体含义同FindClosest。这个节点就是为了寻找光源，用于猪人。 Follow 跟随。这个节点会令生物跟随目标移动。 节点参数如下 inst: 生物自身 target: 搜寻跟随目标的函数 min_dist: 最小距离（目标与生物之间的距离低于此距离，生物会远离目标，直到距离大于target_dist） target_dist: 目标距离（最合适的距离） max_dist: 最大距离（目标与生物之间的距离高于此距离，生物会靠近目标，直到距离小于target_dist） canrun: 是否可以奔跑，决定移动时是走还是跑 Leash 绑定。这个节点会令生物绑定在它的领地上，不会到处乱跑。节点参数inst, homelocation, max_dist, inner_return_dist, running，分别为生物自身，领地位置（可以是具体坐标或一个函数），最大距离（超过此距离时，生物会停止走动，结束本轮的检测），返回距离（超过此距离时，生物会试图返回领地位置），返回时是否奔跑。这个节点实际生效的场景是这样的，生物追逐玩家跑出的领地的最大距离后，会先停在原地，然后等到下一次检测时，返回原本位置。 如果在游戏中仔细观察，就会注意到很多有领地的生物比如龙蝇，在追得太远时都会先停一下才返回。 LeashAndAvoid 绑定并躲避。和ChaseAndAttackAndAvoid类似，参数设置也相似，就是在Leash的基础上增加了躲避，同样也仅仅用于猪人守卫，不再赘述。 Panic 慌乱。这个动作执行时，生物会随机乱窜。 PanicAndAvoid 慌乱并躲避，和ChaseAndAttackAndAvoid类似，同样也仅仅用于猪人守卫，不再赘述。 RunAway 逃离。这个节点可以让生物远离特定目标（这里称为hunter），还可以回家。常见于兔子等生物。 节点参数如下 inst: 生物自身 hunterparams: hunter的相关参数如搜寻函数、标签等 see_dist: 搜寻距离，当发现hunter小于此距离时，会逃跑 safe_dist: 安全距离，开始逃跑后，当hunter大于此时，就会停下 fn: 额外的判定fn，如果这个参数不为空，需要fn返回true才会逃跑 runhome: 是否跑回家。 fix_overhang: 如果参数为true，则会检测生物的位置，如果在海上会被移动到陆地 StalkerChaseAndAttack 一个过期的节点，官方推荐使用ChaseAndAttackAndAvoid替代 StandAndAttack 站在原地攻击。部分没有移动能力的生物，会使用这个节点而不是ChaseAndAttack。参数inst, findnewtargetfn，分别是生物自身，和寻找新目标的函数。第二个参数在官方的代码中并没有用到过。 StandStill 站在原地不动。参数inst, startfn, keepfn，分别是生物自身，开始这个动作的判定函数，保持这个动作的判定函数。这个动作节点很简单，就是让生物保持站在原地不动，如果startfn和keepfn为空，则不需要任何条件，只要行为树访问到这里，就会执行这个动作，保持不动。 UseShield 使用护盾防御。石虾在被攻击时经常会使用这个动作。参数inst, damageforshield, shieldtime, hidefromprojectiles, hidewhenscared，分别为生物自身，当自身收到伤害多少时开启护盾防御，防御持续时间，是否防御远程攻击，在受惊时是否防御。 这个节点制定了进入防御状态和退出防御状态的逻辑，实质上是触发了两个事件，分别是entershield和exitshield。如果你希望构建一种具备防御姿势的生物，可以考虑使用这个节点，并且为事件entershield和exitshield设置相应的回调函数（在官方代码中，是设置了相应的SG的EventHandler) Wander 漫游。生物会在自己的家附近游荡。 参数说明 inst: 生物自身 homelocation: 家的位置，可以是具体的位置或者一个函数 max_dist: 最大游荡距离，生物与家的距离超过此距离时，就会往家里走 times: 这是一个times，分别有minwalktime，randwalktime，minwaittime，randwaittime四个子key，用于设置漫游中间的间隔时间，不需要填完全部参数，都不填也可以，都有默认设置的相应时间。 getdirectionFn: 获取返回的行走角度的函数，没有的时候就随机取一个角度 setdirectionFn: 修正返回行走角度的函数，没有的话就略过。 checkpointFn: 搜寻路径用的检测函数，有时用于绕过围墙。 getdirectionFn，setdirectionFn，checkpointFn这三个参数在实际的使用中较少用到，一般情况下可以忽略。 "}}